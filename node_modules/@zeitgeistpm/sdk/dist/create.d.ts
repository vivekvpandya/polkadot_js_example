import { Observable } from 'rxjs';
import type { FullContext, IndexerContext, RpcContext } from './context/types';
import { MetadataStorage } from './meta';
import { Config, Context, FullConfig, IndexerConfig, RpcConfig, Sdk } from './types';
/**
 * Create an instance of the zeitgeist sdk with full features of both indexer and chain rpc.
 *
 * @mode full
 * @note create with different config to enable indexer or rpc features.
 * @param config FullConfig - Rpc and indexer config
 * @returns Promise<Sdk<FullContext>>
 */
export declare function create<MS extends MetadataStorage<any, any>>(config: FullConfig<MS>): Promise<Sdk<FullContext<MS>, MS>>;
/**
 * Create an instance of the zeitgeist sdk with only rpc features.
 *
 * @mode rpc
 * @note create with different config to enable indexer or rpc features.
 * @param config RpcConfig - Config for the rpc node
 * @returns Promise<Sdk<RpcContext>>
 */
export declare function create<MS extends MetadataStorage<any, any>>(config: RpcConfig<MS>): Promise<Sdk<RpcContext<MS>, MS>>;
/**
 * Create an instance of the zeitgeist sdk with only indexer features.
 *
 * @mode indexer
 * @note create with different config to enable indexer or rpc features.
 * @param config IndexerConfig - Config for the indexer
 * @returns Promise<Sdk<IndexerContext>>
 */
export declare function create<MS extends MetadataStorage<any, any>>(config: IndexerConfig): Promise<Sdk<IndexerContext, MS>>;
/**
 * Initialize the indexer and/or rpc concurrently and emit partially applied intances of the Sdk.
 * Useful when initializing in a UI context where displaying data from the indexer as
 * fast as possible is a priority.
 *
 * Creates a shared observable that replays last emitted sdk instace to late subscribers,
 * and disconnectes the rpc provider when all subscribers unsubscribe.
 *
 * @note If config is indexer and rpc, indexer sdk will emit first.
 *
 * @param config FullConfig
 * @returns Observable<Sdk<Context<MS>, MS>>
 */
export declare const create$: <MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("./meta").CommentMetadata> = MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("./meta").CommentMetadata>>(config: Config<MS>) => Observable<Sdk<Context<MS>, MS>>;
/**
 * Create a full context with both rpc and indexer capabilities.
 *
 * @param config RpcConfig
 * @returns Promise<FullContext>
 */
export declare const createFullContext: <MS extends MetadataStorage<any, any>>(config: FullConfig<MS>) => Promise<FullContext<MS>>;
/**
 * Create an indexer context that only connects to the rpc api.
 *
 * @param config RpcConfig
 * @returns Promise<RpcContext>
 */
export declare const createRpcContext: <MS extends MetadataStorage<any, any>>(config: RpcConfig<MS>) => Promise<RpcContext<MS>>;
/**
 * Create an indexer context that only connects to the gql indexer.
 *
 * @param config IndexerConfig
 * @returns Promise<IndexerContext>
 */
export declare const createIndexerContext: (config: IndexerConfig) => Promise<IndexerContext>;
export default create;
//# sourceMappingURL=create.d.ts.map
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Indexer = require('@zeitgeistpm/indexer');
var rpc = require('@zeitgeistpm/rpc');
var assert = require('@zeitgeistpm/utility/dist/assert');
var observable = require('@zeitgeistpm/utility/dist/observable');
var polly = require('polly-js');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');
var debug = require('./debug.js');
var types$3 = require('./meta/types.js');
require('./meta/market/types.js');
var types$1 = require('./types.js');
var types = require('./config/types.js');
var types$2 = require('./context/types.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var Indexer__namespace = /*#__PURE__*/_interopNamespaceDefault(Indexer);

async function create(config) {
    assert.assert(types.isFullConfig(config) || types.isRpcConfig(config) || types.isIndexerConfig(config), () => new Error(`Initialization error. Config needs to specify at least a valid indexer option or api rpc option.`));
    if (types.isFullConfig(config)) {
        debug.debug(`Using rpc and indexer enabled sdk, indexed data will be prefered when indexer loads.`, config, 'debug');
        return types$1.sdk(await createFullContext(config));
    }
    else if (types.isIndexerConfig(config)) {
        debug.debug(`Using only indexer, no rpc methods or transactions on chain are available to the sdk.`, config, 'warn');
        return types$1.sdk(await createIndexerContext(config));
    }
    else {
        debug.debug(`Using only rpc, querying data might be more limited and/or slower.`, config, 'warn');
        return types$1.sdk(await createRpcContext(config));
    }
}
/**
 * Initialize the indexer and/or rpc concurrently and emit partially applied intances of the Sdk.
 * Useful when initializing in a UI context where displaying data from the indexer as
 * fast as possible is a priority.
 *
 * Creates a shared observable that replays last emitted sdk instace to late subscribers,
 * and disconnectes the rpc provider when all subscribers unsubscribe.
 *
 * @note If config is indexer and rpc, indexer sdk will emit first.
 *
 * @param config FullConfig
 * @returns Observable<Sdk<Context<MS>, MS>>
 */
const create$ = (config) => {
    const config$ = types.isFullConfig(config)
        ? rxjs.of(types.asIndexerConfig(config), types.asRpcConfig(config))
        : rxjs.of(config);
    const context$ = config$.pipe(operators.mergeMap(config => {
        if (types.isIndexerConfig(config)) {
            return rxjs.from(createIndexerContext(config));
        }
        return rxjs.from(createRpcContext(config));
    }), observable.assign());
    const sdk$ = context$.pipe(operators.mergeMap(context => new rxjs.Observable(subscription => {
        subscription.add(() => types$2.teardown(context));
        subscription.next(types$1.sdk(context));
    })));
    return sdk$.pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
};
/**
 * Create a full context with both rpc and indexer capabilities.
 *
 * @param config RpcConfig
 * @returns Promise<FullContext>
 */
const createFullContext = async (config) => {
    const [rpc, indexer] = await Promise.all([
        createRpcContext(config),
        createIndexerContext(config),
    ]);
    return {
        ...rpc,
        ...indexer,
    };
};
/**
 * Create an indexer context that only connects to the rpc api.
 *
 * @param config RpcConfig
 * @returns Promise<RpcContext>
 */
const createRpcContext = async (config) => {
    const { ApiPromise, WsProvider } = await import('@polkadot/api');
    debug.debug(`connecting to rpc: ${config.provider}`, config);
    const provider = await polly()
        .logger(_ => {
        debug.debug(`rpc connection failed, retrying..`, config, 'warn');
    })
        .waitAndRetry(config.connectionRetries ?? 8)
        .executeForPromise(() => new Promise((resolve, reject) => {
        const provider = new WsProvider(config.provider);
        provider.on('error', error => {
            reject(error);
        });
        provider.on('connected', () => {
            resolve(provider);
        });
    }));
    const api = await ApiPromise.create({ ...rpc.options({ provider }) });
    debug.debug(`connected to node rpc`, { ...config, color: '#36a4e3' });
    return {
        api,
        provider,
        storage: types$3.saturate(config.storage),
    };
};
/**
 * Create an indexer context that only connects to the gql indexer.
 *
 * @param config IndexerConfig
 * @returns Promise<IndexerContext>
 */
const createIndexerContext = async (config) => {
    debug.debug(`connecting to indexer: ${config.indexer}`, config);
    const indexer = Indexer__namespace.create({ uri: config.indexer });
    const pinged = await polly()
        .logger(_ => {
        debug.debug(`indexer connection failed, retrying..`, config, 'warn');
    })
        .waitAndRetry(config.connectionRetries ?? 8)
        .executeForPromise(() => indexer.ping());
    debug.debug(`connected to indexer, response time ${pinged}ms`, {
        ...config,
        color: '#52c45e',
    });
    return { indexer };
};

exports.create = create;
exports.create$ = create$;
exports.createFullContext = createFullContext;
exports.createIndexerContext = createIndexerContext;
exports.createRpcContext = createRpcContext;
exports.default = create;
//# sourceMappingURL=create.js.map

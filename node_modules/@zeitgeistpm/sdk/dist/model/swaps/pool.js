'use strict';

var util = require('@polkadot/util');
var rpc = require('@zeitgeistpm/rpc');
var O = require('@zeitgeistpm/utility/dist/option');
var Te = require('@zeitgeistpm/utility/dist/taskeither');
var Decimal = require('decimal.js');
var lodashEs = require('lodash-es');
require('../../primitives/ztg.js');
var assetid = require('../../primitives/assetid.js');
require('../../primitives/blocknumber.js');
require('../../primitives/marketid.js');
var data = require('../../primitives/data.js');
require('@zeitgeistpm/utility/dist/null');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var O__namespace = /*#__PURE__*/_interopNamespaceDefault(O);
var Te__namespace = /*#__PURE__*/_interopNamespaceDefault(Te);

/**
 * Create new RpcPool with associated context, id and on chain primitive.
 *
 * @param ctx RpcContext
 * @param poolId number | u128
 * @param primitive ZeitgeistPrimitivesPool
 * @returns RpcPool
 */
const rpcPool = (ctx, poolId, primitive) => {
    let pool = primitive;
    pool.poolId = util.isNumber(poolId) ? poolId : poolId.toNumber();
    pool.accountId = Te__namespace.from(async () => (await ctx.api.rpc.swaps.poolAccountId(poolId)).toString());
    pool.swapExactAmountIn = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.swapExactAmountIn(poolId, params.assetIn, params.assetAmountIn, params.assetOut, params.minAssetAmountOut ?? null, params.maxPrice ?? null),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.swapExactAmountOut = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.swapExactAmountOut(poolId, params.assetIn, params.maxAssetAmountIn ?? null, params.assetOut, params.assetAmountOut, params.maxPrice ?? null),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.join = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoin(poolId, params.poolAmount, params.maxAssetsIn),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.joinSubsidy = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoinSubsidy(poolId, params.poolAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.joinWithExactAssetAmount = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoinWithExactAssetAmount(poolId, params.assetIn, params.assetAmount, params.minPoolAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.joinWithExactPoolAmount = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoinWithExactPoolAmount(poolId, params.asset, params.poolAmount, params.maxAssetAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exit = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExit(poolId, params.poolAmount, params.minAssetsOut),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exitSubsidy = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExitSubsidy(poolId, params.amount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exitWithExactAssetAmount = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExitWithExactAssetAmount(poolId, params.asset, params.assetAmount, params.maxPoolAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exitWithExactPoolAmount = Te__namespace.from(async (params) => rpc.signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExitWithExactPoolAmount(poolId, params.asset, params.poolAmount, params.minAssetAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    return pool;
};
/**
 * Get the weight of an asset in a pool by its AssetId.
 *
 * @param pool Pool<C, MS>,
 * @param assetId AssetId
 * @returns O.IOption<Decimal>
 */
const getAssetWeight = (pool, assetId) => {
    let weight;
    if (data.isRpcData(pool)) {
        const weights = pool.weights.unwrapOr(null);
        if (!weights) {
            return O__namespace.option(O__namespace.none());
        }
        const entries = [...weights.entries()];
        if (assetid.IOZtgAssetId.is(assetId)) {
            weight = entries.find(([asset]) => asset.isZtg)?.[1]?.toString();
        }
        else if (assetid.IOCategoricalAssetId.is(assetId)) {
            weight = entries
                .find(([asset]) => asset.isCategoricalOutcome &&
                asset.asCategoricalOutcome[1].toNumber() === assetid.getIndexOf(assetId))
                ?.toString();
        }
        else if (assetid.IOScalarAssetId.is(assetId)) {
            weight = entries
                .find(([asset]) => asset.isScalarOutcome &&
                ((asset.asScalarOutcome[1].isLong && assetId.ScalarOutcome[1] === 'Long') ||
                    (asset.asScalarOutcome[1].isShort && assetId.ScalarOutcome[1] === 'Short')))
                ?.toString();
        }
    }
    else {
        weight = pool.weights.find(weight => weight?.assetId && lodashEs.isEqual(assetid.parseAssetId(weight?.assetId).unwrap(), assetId))?.len;
    }
    return weight ? O__namespace.option(O__namespace.some(new Decimal(weight))) : O__namespace.option(O__namespace.none());
};
/**
 * Map storage entries to rpc pools
 *
 * @param ctx RpcContext<MS>
 * @param entries [StorageKey<[u128]>, Option<ZeitgeistPrimitivesPool>][]
 * @returns RpcPool[]
 */
const fromEntries = (ctx, entries) => {
    return entries.map(([{ args: [poolId], }, pool,]) => rpcPool(ctx, poolId.toNumber(), pool.unwrap()));
};

exports.fromEntries = fromEntries;
exports.getAssetWeight = getAssetWeight;
exports.rpcPool = rpcPool;
//# sourceMappingURL=pool.js.map

import { isNumber } from '@polkadot/util';
import { signAndSend } from '@zeitgeistpm/rpc';
import * as O from '@zeitgeistpm/utility/dist/option';
import * as Te from '@zeitgeistpm/utility/dist/taskeither';
import Decimal from 'decimal.js';
import { isEqual } from 'lodash-es';
import '../../primitives/ztg.mjs';
import { IOZtgAssetId, IOCategoricalAssetId, getIndexOf, IOScalarAssetId, parseAssetId } from '../../primitives/assetid.mjs';
import '../../primitives/blocknumber.mjs';
import '../../primitives/marketid.mjs';
import { isRpcData } from '../../primitives/data.mjs';
import '@zeitgeistpm/utility/dist/null';

/**
 * Create new RpcPool with associated context, id and on chain primitive.
 *
 * @param ctx RpcContext
 * @param poolId number | u128
 * @param primitive ZeitgeistPrimitivesPool
 * @returns RpcPool
 */
const rpcPool = (ctx, poolId, primitive) => {
    let pool = primitive;
    pool.poolId = isNumber(poolId) ? poolId : poolId.toNumber();
    pool.accountId = Te.from(async () => (await ctx.api.rpc.swaps.poolAccountId(poolId)).toString());
    pool.swapExactAmountIn = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.swapExactAmountIn(poolId, params.assetIn, params.assetAmountIn, params.assetOut, params.minAssetAmountOut ?? null, params.maxPrice ?? null),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.swapExactAmountOut = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.swapExactAmountOut(poolId, params.assetIn, params.maxAssetAmountIn ?? null, params.assetOut, params.assetAmountOut, params.maxPrice ?? null),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.join = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoin(poolId, params.poolAmount, params.maxAssetsIn),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.joinSubsidy = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoinSubsidy(poolId, params.poolAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.joinWithExactAssetAmount = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoinWithExactAssetAmount(poolId, params.assetIn, params.assetAmount, params.minPoolAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.joinWithExactPoolAmount = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolJoinWithExactPoolAmount(poolId, params.asset, params.poolAmount, params.maxAssetAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exit = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExit(poolId, params.poolAmount, params.minAssetsOut),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exitSubsidy = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExitSubsidy(poolId, params.amount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exitWithExactAssetAmount = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExitWithExactAssetAmount(poolId, params.asset, params.assetAmount, params.maxPoolAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    pool.exitWithExactPoolAmount = Te.from(async (params) => signAndSend({
        api: ctx.api,
        tx: ctx.api.tx.swaps.poolExitWithExactPoolAmount(poolId, params.asset, params.poolAmount, params.minAssetAmount),
        signer: params.signer,
        hooks: params.hooks,
    }));
    return pool;
};
/**
 * Get the weight of an asset in a pool by its AssetId.
 *
 * @param pool Pool<C, MS>,
 * @param assetId AssetId
 * @returns O.IOption<Decimal>
 */
const getAssetWeight = (pool, assetId) => {
    let weight;
    if (isRpcData(pool)) {
        const weights = pool.weights.unwrapOr(null);
        if (!weights) {
            return O.option(O.none());
        }
        const entries = [...weights.entries()];
        if (IOZtgAssetId.is(assetId)) {
            weight = entries.find(([asset]) => asset.isZtg)?.[1]?.toString();
        }
        else if (IOCategoricalAssetId.is(assetId)) {
            weight = entries
                .find(([asset]) => asset.isCategoricalOutcome &&
                asset.asCategoricalOutcome[1].toNumber() === getIndexOf(assetId))
                ?.toString();
        }
        else if (IOScalarAssetId.is(assetId)) {
            weight = entries
                .find(([asset]) => asset.isScalarOutcome &&
                ((asset.asScalarOutcome[1].isLong && assetId.ScalarOutcome[1] === 'Long') ||
                    (asset.asScalarOutcome[1].isShort && assetId.ScalarOutcome[1] === 'Short')))
                ?.toString();
        }
    }
    else {
        weight = pool.weights.find(weight => weight?.assetId && isEqual(parseAssetId(weight?.assetId).unwrap(), assetId))?.len;
    }
    return weight ? O.option(O.some(new Decimal(weight))) : O.option(O.none());
};
/**
 * Map storage entries to rpc pools
 *
 * @param ctx RpcContext<MS>
 * @param entries [StorageKey<[u128]>, Option<ZeitgeistPrimitivesPool>][]
 * @returns RpcPool[]
 */
const fromEntries = (ctx, entries) => {
    return entries.map(([{ args: [poolId], }, pool,]) => rpcPool(ctx, poolId.toNumber(), pool.unwrap()));
};

export { fromEntries, getAssetWeight, rpcPool };
//# sourceMappingURL=pool.mjs.map

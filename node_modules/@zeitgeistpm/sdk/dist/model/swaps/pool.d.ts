import type { Option, StorageKey, u128, Vec } from '@polkadot/types';
import type { ZeitgeistPrimitivesAsset, ZeitgeistPrimitivesPool } from '@polkadot/types/lookup';
import type { ISubmittableResult } from '@polkadot/types/types';
import { PoolsQuery } from '@zeitgeistpm/indexer';
import { KeyringPairOrExtSigner, TransactionError, TransactionHooks } from '@zeitgeistpm/rpc';
import { Unpacked } from '@zeitgeistpm/utility/dist/array';
import * as O from '@zeitgeistpm/utility/dist/option';
import * as Te from '@zeitgeistpm/utility/dist/taskeither';
import Decimal from 'decimal.js';
import { Context, IndexerContext, RpcContext } from '../../context';
import { MetadataStorage } from '../../meta';
import { AssetId } from '../../primitives';
import { Data } from '../../primitives/data';
/**
 * Union Pool type of indexed and rpc types.
 * Will differentiate between indexer and rpc context
 *
 * @generic C Context - the context to fetch the marketlist for.
 */
export declare type Pool<C extends Context<MS>, MS extends MetadataStorage = MetadataStorage> = Data<C, C extends RpcContext<MS> ? RpcPool : never, C extends IndexerContext ? IndexedPool<C, MS> : never, MS>;
/**
 * Concrete Pool type for indexed Pool.
 */
export declare type IndexedPool<C extends Context<MS>, MS extends MetadataStorage = MetadataStorage> = Unpacked<PoolsQuery['pools']> & (C extends RpcContext<MS> ? PoolMethods : {});
/**
 * Concrete Pool type for rpc Pool.
 */
export declare type RpcPool = (ZeitgeistPrimitivesPool & PoolMethods) & {
    /**
     * The pool id/index on chain.
     */
    poolId: number;
};
export declare type PoolMethods = {
    /**
     * Get the account id for the pool.
     */
    accountId: Te.TaskEither<Error, string, []>;
    swapExactAmountIn: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<SwapExactAmountInParams, 'poolId'> & TransactionHooks
    ]>;
    swapExactAmountOut: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<SwapExactAmountOutParams, 'poolId'> & TransactionHooks
    ]>;
    join: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolJoinParams, 'poolId'> & TransactionHooks
    ]>;
    joinSubsidy: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolJoinParams, 'poolId' | 'maxAssetsIn'> & TransactionHooks
    ]>;
    joinWithExactAssetAmount: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolJoinWithExactAmountParams, 'poolId'> & TransactionHooks
    ]>;
    joinWithExactPoolAmount: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolJoinWithExactPoolAmount, 'poolId'> & TransactionHooks
    ]>;
    exit: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolExitParams, 'poolId'> & TransactionHooks
    ]>;
    exitSubsidy: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolExitSubsidyParams, 'poolId'> & TransactionHooks
    ]>;
    exitWithExactAssetAmount: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolExitWithExactAssetAmountParams, 'poolId'> & TransactionHooks
    ]>;
    exitWithExactPoolAmount: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<PoolExitWithExactPoolAmountParams, 'poolId'> & TransactionHooks
    ]>;
};
/**
 * Params needed to create a pool.
 */
export declare type PoolDeploymentParams = {
    marketId: number | u128;
    swapFee: string | number | u128;
    amount: string | number | u128;
    weights: Array<string | number | u128>;
    signer: KeyringPairOrExtSigner;
};
/**
 * Params needed to exhange(buy or sell) a full set of assets for a pool.
 */
export declare type ExchangeFullSetParams = {
    marketId: number | u128;
    amount: number;
    signer: KeyringPairOrExtSigner;
};
export declare type SwapExactAmountInParams = {
    poolId: u128 | number | Uint8Array;
    assetIn: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    assetAmountIn: u128 | number | Uint8Array;
    assetOut: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    minAssetAmountOut?: u128 | number | Uint8Array;
    maxPrice?: u128 | number | Uint8Array;
    signer: KeyringPairOrExtSigner;
};
export declare type SwapExactAmountOutParams = {
    poolId: u128 | number | Uint8Array;
    assetIn: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    maxAssetAmountIn?: u128 | number | Uint8Array | null;
    assetOut: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    assetAmountOut: u128 | number | Uint8Array;
    maxPrice?: u128 | number | Uint8Array | null;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolJoinParams = {
    poolId: u128 | number | Uint8Array;
    poolAmount: u128 | number | Uint8Array;
    maxAssetsIn: Vec<u128> | Array<u128 | number | Uint8Array>;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolJoinWithExactAmountParams = {
    poolId: u128 | number | Uint8Array;
    assetIn: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    assetAmount: u128 | number | Uint8Array;
    minPoolAmount: u128 | number | Uint8Array;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolJoinWithExactPoolAmount = {
    poolId: u128 | number | Uint8Array;
    asset: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    poolAmount: u128 | number | Uint8Array;
    maxAssetAmount: u128 | number | Uint8Array;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolExitParams = {
    poolId: u128 | number | Uint8Array;
    poolAmount: u128 | number | Uint8Array;
    minAssetsOut: Vec<u128> | Array<u128 | number | Uint8Array>;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolExitSubsidyParams = {
    poolId: u128 | number | Uint8Array;
    amount: u128 | number | Uint8Array;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolExitWithExactAssetAmountParams = {
    poolId: u128 | number | Uint8Array;
    asset: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    assetAmount: u128 | number | Uint8Array;
    maxPoolAmount: u128 | number | Uint8Array;
    signer: KeyringPairOrExtSigner;
};
export declare type PoolExitWithExactPoolAmountParams = {
    poolId: u128 | number | Uint8Array;
    asset: ZeitgeistPrimitivesAsset | AssetId | Uint8Array;
    poolAmount: u128 | number | Uint8Array;
    minAssetAmount: u128 | number | Uint8Array;
    signer: KeyringPairOrExtSigner;
};
/**
 * Create new RpcPool with associated context, id and on chain primitive.
 *
 * @param ctx RpcContext
 * @param poolId number | u128
 * @param primitive ZeitgeistPrimitivesPool
 * @returns RpcPool
 */
export declare const rpcPool: (ctx: RpcContext, poolId: number | u128, primitive: ZeitgeistPrimitivesPool) => RpcPool;
/**
 * Get the weight of an asset in a pool by its AssetId.
 *
 * @param pool Pool<C, MS>,
 * @param assetId AssetId
 * @returns O.IOption<Decimal>
 */
export declare const getAssetWeight: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(pool: Data<C, C extends RpcContext<MS> ? RpcPool : never, C extends IndexerContext ? IndexedPool<C, MS> : never, MS>, assetId: AssetId) => O.IOption<Decimal>;
/**
 * Map storage entries to rpc pools
 *
 * @param ctx RpcContext<MS>
 * @param entries [StorageKey<[u128]>, Option<ZeitgeistPrimitivesPool>][]
 * @returns RpcPool[]
 */
export declare const fromEntries: <C extends RpcContext<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(ctx: C, entries: [StorageKey<[u128]>, Option<ZeitgeistPrimitivesPool>][]) => Data<C, C extends RpcContext<MS> ? RpcPool : never, C extends IndexerContext ? IndexedPool<C, MS> : never, MS>[];
//# sourceMappingURL=pool.d.ts.map
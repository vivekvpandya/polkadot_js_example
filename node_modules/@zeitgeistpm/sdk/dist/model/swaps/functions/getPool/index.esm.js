import { of, Observable } from 'rxjs';
import * as O from '@zeitgeistpm/utility/dist/option';
import { switchMap } from 'rxjs/operators';
import { isIndexerContext, isRpcContext } from '../../../../context/types.esm.js';
import { rpcPool } from '../../pool.esm.js';
import { isMarketIdQuery } from './types.esm.js';

/**
 * Fetch a pool by its market id or pool id.
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query in
 * @param query PoolGetQuery
 * @returns Promise<Pool<C>>
 */
const getPool = async (context, query) => {
    if (isIndexerContext(context)) {
        return getFromIndexer(context, query);
    }
    else if (isRpcContext(context)) {
        return getFromRpc(context, query);
    }
    throw new Error('unrechable code detected.');
};
/**
 * Concrete get function for indexer context
 * @private
 */
const getFromIndexer = async (context, query) => {
    const { pools: [pool], } = await context.indexer.pools({
        where: isMarketIdQuery(query)
            ? { marketId_eq: query.marketId }
            : { poolId_eq: query.poolId },
    });
    if (pool) {
        return O.option(O.some(pool));
    }
    return O.option(O.none());
};
/**
 * Concrete get function for rpc context
 * @private
 */
const getFromRpc = async (context, query) => {
    let poolId;
    if (isMarketIdQuery(query)) {
        const mPoolId = await context.api.query.marketCommons.marketPool(query.marketId);
        if (mPoolId.isNone)
            O.option(O.none());
        poolId = mPoolId.unwrap().toNumber();
    }
    else {
        poolId = query.poolId;
    }
    const marketPool = await context.api.query.swaps.pools(poolId);
    if (marketPool.isNone)
        O.option(O.none());
    return O.option(O.some(rpcPool(context, poolId, marketPool.unwrap())));
};
/**
 * Fetch pool and stream changes from rpc.
 *
 * @param context RpcContext
 * @param query PoolGetQuery
 * @returns Observable<Pool<C, MS>>
 */
const observePool$ = (context, query) => {
    const poolId$ = isMarketIdQuery(query)
        ? observeMarketPoolId$(context, query.marketId)
        : of(query.poolId);
    return poolId$.pipe(switchMap(poolId => new Observable(subscription => {
        const unsub = context.api.query.swaps.pools(poolId, pool => {
            if (pool.isNone)
                return subscription.complete();
            subscription.next(rpcPool(context, poolId, pool.unwrap()));
        });
        return () => {
            subscription.complete();
            unsub.then(unsub => unsub());
        };
    })));
};
/**
 * Observe the pool id of a market. Usefull for starting to observe the pool of a market
 * at any time even before it is created.
 *
 * @param context RpcContext<MS>
 * @param marketId number
 * @returns Observable<number>
 */
const observeMarketPoolId$ = (context, marketId) => {
    return new Observable(subscription => {
        context.api.query.marketCommons.marketPool(marketId, poolId => {
            if (poolId.isSome) {
                subscription.next(poolId.unwrap().toNumber());
            }
        });
    });
};

export { getPool, observeMarketPoolId$, observePool$ };
//# sourceMappingURL=index.esm.js.map

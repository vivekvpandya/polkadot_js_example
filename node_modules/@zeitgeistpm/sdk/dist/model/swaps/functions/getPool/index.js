'use strict';

var rxjs = require('rxjs');
var O = require('@zeitgeistpm/utility/dist/option');
var operators = require('rxjs/operators');
var types = require('../../../../context/types.js');
var pool = require('../../pool.js');
var types$1 = require('./types.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var O__namespace = /*#__PURE__*/_interopNamespaceDefault(O);

/**
 * Fetch a pool by its market id or pool id.
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query in
 * @param query PoolGetQuery
 * @returns Promise<Pool<C>>
 */
const getPool = async (context, query) => {
    if (types.isIndexerContext(context)) {
        return getFromIndexer(context, query);
    }
    else if (types.isRpcContext(context)) {
        return getFromRpc(context, query);
    }
    throw new Error('unrechable code detected.');
};
/**
 * Concrete get function for indexer context
 * @private
 */
const getFromIndexer = async (context, query) => {
    const { pools: [pool], } = await context.indexer.pools({
        where: types$1.isMarketIdQuery(query)
            ? { marketId_eq: query.marketId }
            : { poolId_eq: query.poolId },
    });
    if (pool) {
        return O__namespace.option(O__namespace.some(pool));
    }
    return O__namespace.option(O__namespace.none());
};
/**
 * Concrete get function for rpc context
 * @private
 */
const getFromRpc = async (context, query) => {
    let poolId;
    if (types$1.isMarketIdQuery(query)) {
        const mPoolId = await context.api.query.marketCommons.marketPool(query.marketId);
        if (mPoolId.isNone)
            O__namespace.option(O__namespace.none());
        poolId = mPoolId.unwrap().toNumber();
    }
    else {
        poolId = query.poolId;
    }
    const marketPool = await context.api.query.swaps.pools(poolId);
    if (marketPool.isNone)
        O__namespace.option(O__namespace.none());
    return O__namespace.option(O__namespace.some(pool.rpcPool(context, poolId, marketPool.unwrap())));
};
/**
 * Fetch pool and stream changes from rpc.
 *
 * @param context RpcContext
 * @param query PoolGetQuery
 * @returns Observable<Pool<C, MS>>
 */
const observePool$ = (context, query) => {
    const poolId$ = types$1.isMarketIdQuery(query)
        ? observeMarketPoolId$(context, query.marketId)
        : rxjs.of(query.poolId);
    return poolId$.pipe(operators.switchMap(poolId => new rxjs.Observable(subscription => {
        const unsub = context.api.query.swaps.pools(poolId, pool$1 => {
            if (pool$1.isNone)
                return subscription.complete();
            subscription.next(pool.rpcPool(context, poolId, pool$1.unwrap()));
        });
        return () => {
            subscription.complete();
            unsub.then(unsub => unsub());
        };
    })));
};
/**
 * Observe the pool id of a market. Usefull for starting to observe the pool of a market
 * at any time even before it is created.
 *
 * @param context RpcContext<MS>
 * @param marketId number
 * @returns Observable<number>
 */
const observeMarketPoolId$ = (context, marketId) => {
    return new rxjs.Observable(subscription => {
        context.api.query.marketCommons.marketPool(marketId, poolId => {
            if (poolId.isSome) {
                subscription.next(poolId.unwrap().toNumber());
            }
        });
    });
};

exports.getPool = getPool;
exports.observeMarketPoolId$ = observeMarketPoolId$;
exports.observePool$ = observePool$;
//# sourceMappingURL=index.js.map

{"version":3,"file":"index.esm.js","sources":["../../../../../src/model/swaps/functions/saturatedPoolsIndex/index.ts"],"sourcesContent":["import { mapget } from '@zeitgeistpm/utility/dist/btreemap'\nimport { isNotNull } from '@zeitgeistpm/utility/dist/null'\nimport { Decimal } from 'decimal.js'\nimport {\n  Context,\n  IndexerContext,\n  isIndexerContext,\n  isRpcContext,\n  RpcContext,\n} from '../../../../context'\nimport { MetadataStorage } from '../../../../meta'\nimport * as AssetId from '../../../../primitives/assetid'\nimport { ZTG } from '../../../../primitives/ztg'\nimport { rpcMarket } from '../../../markets'\nimport { Pool } from '../../pool'\nimport { SaturatedPoolEntryAsset, SaturatedPoolIndex } from './types'\n\nexport * from './types'\n\n/**\n * Get an asset index for a list of pools from either rpc or indexer.\n *\n * @param context C\n * @param pools Pool<C, M\n * @returns Promise<AssetIndex>\n */\nexport const saturatedPoolsIndex = async <\n  C extends Context<MS>,\n  MS extends MetadataStorage,\n>(\n  context: C,\n  pools: Pool<C, MS>[],\n): Promise<SaturatedPoolIndex<C, MS>> => {\n  if (isIndexerContext<MS>(context)) {\n    return indexer<typeof context, MS>(context, pools)\n  } else if (isRpcContext<MS>(context)) {\n    return rpc<typeof context, MS>(context, pools)\n  }\n  throw new Error('Unreachable context.')\n}\n\n/**\n * Get an assets index for a list of pools from the indexer.\n *\n * @param ctx IndexerContext\n * @param pools Pool<C, M\n * @returns Promise<AssetIndex>\n */\nexport const indexer = async <C extends IndexerContext, MS extends MetadataStorage>(\n  ctx: C,\n  pools: Pool<C, MS>[],\n): Promise<SaturatedPoolIndex<C, MS>> => {\n  const ids = pools.map(p => p.poolId)\n\n  const [{ markets: marketsForPools }, { assets: assetsForPools }] = await Promise.all([\n    ctx.indexer.markets({\n      where: {\n        pool: {\n          poolId_in: ids,\n        },\n      },\n    }),\n    ctx.indexer.assets({\n      where: {\n        poolId_in: ids,\n      },\n    }),\n  ])\n\n  const byPool = (\n    await Promise.all(\n      pools.map(async pool => {\n        const poolMarket = marketsForPools.find(m => m.pool?.poolId === pool.poolId)\n        const poolAssets = assetsForPools.filter(a => a.poolId === pool.poolId)\n\n        if (pool?.poolId === 167) {\n          console.log(poolAssets)\n        }\n\n        if (!poolMarket || poolAssets.length === 0) return null\n\n        const assets: SaturatedPoolEntryAsset[] = pool.weights\n          .filter(isNotNull)\n          .map(weight => {\n            const assetId = AssetId.parseAssetId(weight.assetId).unwrap()!\n            const assetIndex = AssetId.getIndexOf(assetId)!\n\n            const percentage = Math.round(\n              new Decimal(weight.len).dividedBy(pool.totalWeight).mul(100).toNumber(),\n            )\n\n            if (AssetId.IOZtgAssetId.is(assetId)) {\n              return {\n                amount: new Decimal(pool.ztgQty),\n                price: ZTG,\n                assetId,\n                category: {\n                  ticker: 'ZTG',\n                  name: 'ztg',\n                },\n                percentage,\n              }\n            }\n\n            const asset = poolAssets.find(a => a.assetId === weight.assetId)!\n\n            const category = !poolMarket.categories\n              ? {\n                  name: `unknown[${assetIndex}]`,\n                  ticker: `UNKN-${assetIndex}`,\n                }\n              : poolMarket.categories?.[assetIndex] ?? {\n                  name: 'ztg',\n                  ticker: 'ZTG',\n                }\n\n            return {\n              amount: new Decimal(asset.amountInPool),\n              price: new Decimal(asset.price ?? 0).mul(ZTG),\n              category,\n              assetId,\n              percentage,\n            }\n          })\n          .filter(isNotNull)\n\n        const liquidity = assets.reduce((total, asset) => {\n          if (!asset.price || !asset.amount) {\n            return total\n          }\n          return total.plus(\n            new Decimal(asset.price.div(ZTG)).mul(new Decimal(asset.amount)),\n          )\n        }, new Decimal(0))\n\n        return { poolId: pool.poolId, market: poolMarket, liquidity, assets }\n      }),\n    )\n  ).filter(isNotNull)\n\n  return byPool.reduce(\n    (index, { poolId, market, liquidity, assets }) => ({\n      ...index,\n      [poolId]: { liquidity, market, assets },\n    }),\n    {},\n  )\n}\n\n/**\n * Get an asset index for a list of pools from node rpc.\n *\n * @param ctx RpcContext<MS>\n * @param pools Pool<C, M\n * @returns Promise<AssetIndex>\n */\nexport const rpc = async <C extends RpcContext<MS>, MS extends MetadataStorage>(\n  ctx: C,\n  pools: Pool<C, MS>[],\n): Promise<SaturatedPoolIndex<C, MS>> => {\n  const byPool = await Promise.all(\n    pools.map(async pool => {\n      const outcomeAssets = pool.assets.filter(a => !a.isZtg)\n      const swapPrct = new Decimal(pool.swapFee.unwrap().toNumber()).dividedBy(100000000)\n      const weights = pool.weights.unwrap()\n\n      const accountId = await pool.accountId().unwrap()\n\n      const [market, prices, tokens, ztgBalance] = await Promise.all([\n        ctx.api.query.marketCommons\n          .markets(pool.marketId)\n          .then(m => rpcMarket(ctx, pool.marketId, m.unwrap()).saturate()),\n        Promise.all(\n          pool.assets.map(asset =>\n            ctx.api.rpc.swaps.getSpotPrice(pool.poolId, { Ztg: null }, asset, null, false),\n          ),\n        ),\n        ctx.api.query.tokens.accounts.multi(outcomeAssets.map(asset => [accountId, asset])),\n        ctx.api.query.system.account(accountId).then(({ data }) => data.free),\n      ])\n\n      const accounts = [...tokens.map(t => t.free), ztgBalance]\n\n      let liquidity = pool.assets.reduce((total, asset, index) => {\n        const price = prices[index]\n        const amountInPool = accounts[index]\n        return total.plus(\n          new Decimal(price.toNumber()).div(ZTG).mul(amountInPool.toNumber()),\n        )\n      }, new Decimal(0))\n\n      liquidity = liquidity.minus(liquidity.dividedBy(100).mul(swapPrct))\n\n      const totalWeight = pool.assets.reduce((total, asset) => {\n        const weight = new Decimal(mapget(weights, asset)?.toNumber() ?? 0)\n        return total.plus(weight)\n      }, new Decimal(0))\n\n      const assets: SaturatedPoolEntryAsset[] = pool.assets.map((asset, index) => {\n        return {\n          amount: new Decimal(accounts[index].toNumber()),\n          price: new Decimal(prices[index].toNumber()),\n          assetId: AssetId.fromPrimitive(asset),\n          category: market.categories?.[index] || {\n            name: 'ztg',\n            ticker: 'ZTG',\n          },\n          percentage: new Decimal(mapget(weights, asset)?.toNumber() ?? 0)\n            .dividedBy(totalWeight)\n            .toNumber(),\n        }\n      })\n\n      return { poolId: pool.poolId, market, liquidity, assets }\n    }),\n  )\n\n  return byPool.reduce(\n    (index, { poolId, market, liquidity, assets }) => ({\n      ...index,\n      [poolId]: { market, liquidity, assets },\n    }),\n    {},\n  )\n}\n"],"names":["AssetId.parseAssetId","AssetId.getIndexOf","AssetId.IOZtgAssetId","AssetId.fromPrimitive"],"mappings":"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"}
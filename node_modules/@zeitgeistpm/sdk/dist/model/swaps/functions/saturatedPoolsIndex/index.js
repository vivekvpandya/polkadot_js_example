'use strict';

var btreemap = require('@zeitgeistpm/utility/dist/btreemap');
var _null = require('@zeitgeistpm/utility/dist/null');
var Decimal = require('decimal.js');
var types = require('../../../../context/types.js');
var assetid = require('../../../../primitives/assetid.js');
var ztg = require('../../../../primitives/ztg.js');
require('@zeitgeistpm/utility/dist/pfunc');
require('@zeitgeistpm/utility/dist/taskeither');
require('@zeitgeistpm/rpc');
require('@zeitgeistpm/utility/dist/either');
require('@polkadot/util');
require('@zeitgeistpm/utility/dist/option');
require('lodash-es');
require('../../../../primitives/blocknumber.js');
require('../../../../primitives/marketid.js');
var market = require('../../../markets/market.js');
require('rxjs');
require('@zeitgeistpm/utility/dist/infinity');
require('@zeitgeistpm/utility/dist/time');

/**
 * Get an asset index for a list of pools from either rpc or indexer.
 *
 * @param context C
 * @param pools Pool<C, M
 * @returns Promise<AssetIndex>
 */
const saturatedPoolsIndex = async (context, pools) => {
    if (types.isIndexerContext(context)) {
        return indexer(context, pools);
    }
    else if (types.isRpcContext(context)) {
        return rpc(context, pools);
    }
    throw new Error('Unreachable context.');
};
/**
 * Get an assets index for a list of pools from the indexer.
 *
 * @param ctx IndexerContext
 * @param pools Pool<C, M
 * @returns Promise<AssetIndex>
 */
const indexer = async (ctx, pools) => {
    const ids = pools.map(p => p.poolId);
    const [{ markets: marketsForPools }, { assets: assetsForPools }] = await Promise.all([
        ctx.indexer.markets({
            where: {
                pool: {
                    poolId_in: ids,
                },
            },
        }),
        ctx.indexer.assets({
            where: {
                poolId_in: ids,
            },
        }),
    ]);
    const byPool = (await Promise.all(pools.map(async (pool) => {
        const poolMarket = marketsForPools.find(m => m.pool?.poolId === pool.poolId);
        const poolAssets = assetsForPools.filter(a => a.poolId === pool.poolId);
        if (pool?.poolId === 167) {
            console.log(poolAssets);
        }
        if (!poolMarket || poolAssets.length === 0)
            return null;
        const assets = pool.weights
            .filter(_null.isNotNull)
            .map(weight => {
            const assetId = assetid.parseAssetId(weight.assetId).unwrap();
            const assetIndex = assetid.getIndexOf(assetId);
            const percentage = Math.round(new Decimal.Decimal(weight.len).dividedBy(pool.totalWeight).mul(100).toNumber());
            if (assetid.IOZtgAssetId.is(assetId)) {
                return {
                    amount: new Decimal.Decimal(pool.ztgQty),
                    price: ztg.ZTG,
                    assetId,
                    category: {
                        ticker: 'ZTG',
                        name: 'ztg',
                    },
                    percentage,
                };
            }
            const asset = poolAssets.find(a => a.assetId === weight.assetId);
            const category = !poolMarket.categories
                ? {
                    name: `unknown[${assetIndex}]`,
                    ticker: `UNKN-${assetIndex}`,
                }
                : poolMarket.categories?.[assetIndex] ?? {
                    name: 'ztg',
                    ticker: 'ZTG',
                };
            return {
                amount: new Decimal.Decimal(asset.amountInPool),
                price: new Decimal.Decimal(asset.price ?? 0).mul(ztg.ZTG),
                category,
                assetId,
                percentage,
            };
        })
            .filter(_null.isNotNull);
        const liquidity = assets.reduce((total, asset) => {
            if (!asset.price || !asset.amount) {
                return total;
            }
            return total.plus(new Decimal.Decimal(asset.price.div(ztg.ZTG)).mul(new Decimal.Decimal(asset.amount)));
        }, new Decimal.Decimal(0));
        return { poolId: pool.poolId, market: poolMarket, liquidity, assets };
    }))).filter(_null.isNotNull);
    return byPool.reduce((index, { poolId, market, liquidity, assets }) => ({
        ...index,
        [poolId]: { liquidity, market, assets },
    }), {});
};
/**
 * Get an asset index for a list of pools from node rpc.
 *
 * @param ctx RpcContext<MS>
 * @param pools Pool<C, M
 * @returns Promise<AssetIndex>
 */
const rpc = async (ctx, pools) => {
    const byPool = await Promise.all(pools.map(async (pool) => {
        const outcomeAssets = pool.assets.filter(a => !a.isZtg);
        const swapPrct = new Decimal.Decimal(pool.swapFee.unwrap().toNumber()).dividedBy(100000000);
        const weights = pool.weights.unwrap();
        const accountId = await pool.accountId().unwrap();
        const [market$1, prices, tokens, ztgBalance] = await Promise.all([
            ctx.api.query.marketCommons
                .markets(pool.marketId)
                .then(m => market.rpcMarket(ctx, pool.marketId, m.unwrap()).saturate()),
            Promise.all(pool.assets.map(asset => ctx.api.rpc.swaps.getSpotPrice(pool.poolId, { Ztg: null }, asset, null, false))),
            ctx.api.query.tokens.accounts.multi(outcomeAssets.map(asset => [accountId, asset])),
            ctx.api.query.system.account(accountId).then(({ data }) => data.free),
        ]);
        const accounts = [...tokens.map(t => t.free), ztgBalance];
        let liquidity = pool.assets.reduce((total, asset, index) => {
            const price = prices[index];
            const amountInPool = accounts[index];
            return total.plus(new Decimal.Decimal(price.toNumber()).div(ztg.ZTG).mul(amountInPool.toNumber()));
        }, new Decimal.Decimal(0));
        liquidity = liquidity.minus(liquidity.dividedBy(100).mul(swapPrct));
        const totalWeight = pool.assets.reduce((total, asset) => {
            const weight = new Decimal.Decimal(btreemap.mapget(weights, asset)?.toNumber() ?? 0);
            return total.plus(weight);
        }, new Decimal.Decimal(0));
        const assets = pool.assets.map((asset, index) => {
            return {
                amount: new Decimal.Decimal(accounts[index].toNumber()),
                price: new Decimal.Decimal(prices[index].toNumber()),
                assetId: assetid.fromPrimitive(asset),
                category: market$1.categories?.[index] || {
                    name: 'ztg',
                    ticker: 'ZTG',
                },
                percentage: new Decimal.Decimal(btreemap.mapget(weights, asset)?.toNumber() ?? 0)
                    .dividedBy(totalWeight)
                    .toNumber(),
            };
        });
        return { poolId: pool.poolId, market: market$1, liquidity, assets };
    }));
    return byPool.reduce((index, { poolId, market, liquidity, assets }) => ({
        ...index,
        [poolId]: { market, liquidity, assets },
    }), {});
};

exports.indexer = indexer;
exports.rpc = rpc;
exports.saturatedPoolsIndex = saturatedPoolsIndex;
//# sourceMappingURL=index.js.map

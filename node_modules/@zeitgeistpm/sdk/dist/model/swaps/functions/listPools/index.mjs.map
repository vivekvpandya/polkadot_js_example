{"version":3,"file":"index.mjs","sources":["../../../../../src/model/swaps/functions/listPools/index.ts"],"sourcesContent":["import type { Option, StorageKey, u128 } from '@polkadot/types'\nimport type { ZeitgeistPrimitivesPool } from '@polkadot/types/lookup'\nimport { isNull } from '@polkadot/util'\nimport {\n  Context,\n  IndexerContext,\n  isFullContext,\n  isIndexerContext,\n  isRpcContext,\n  RpcContext,\n} from '../../../../context/types'\nimport { MetadataStorage } from '../../../../meta'\nimport { isPaginated } from '../../../../primitives/pagination'\nimport { fromEntries, Pool } from '../../pool'\nimport { PoolList } from '../../poolslist'\nimport { PoolsListQuery } from '../../types'\n\n/**\n * Query for a list of pools.\n * Query capabilities and returned data differentiates between a rpc and indexer context.\n *\n * @generic C - Context\n * @param context C - the context to query in\n * @param query ListQuery<C>\n * @returns Promise<PoolList<C>>\n */\nexport const listPools = async <C extends Context<MS>, MS extends MetadataStorage>(\n  context: C,\n  query: PoolsListQuery<C, MS>,\n): Promise<PoolList<C, MS>> => {\n  const pools =\n    isFullContext<MS>(context) || isIndexerContext<MS>(context)\n      ? await listFromIndexer<typeof context, MS>(context, query)\n      : isRpcContext<MS>(context)\n      ? await listFromRpc<typeof context, MS>(context, query)\n      : null\n\n  if (isNull(pools)) {\n    throw new Error('No pools. Should be unreachable code path')\n  }\n\n  return pools as PoolList<C, MS>\n}\n\n/**\n * Concrete listing function for indexer context\n * @private\n */\nconst listFromIndexer = async <C extends IndexerContext, MS extends MetadataStorage>(\n  context: C,\n  query: PoolsListQuery<C, MS>,\n): Promise<Pool<C, MS>[]> => {\n  return (await context.indexer.pools(query)).pools as Pool<C, MS>[]\n}\n\n/**\n * Concrete listing function for rpc context\n * @private\n */\nconst listFromRpc = async <C extends RpcContext<MS>, MS extends MetadataStorage>(\n  ctx: C,\n  query?: PoolsListQuery<C, MS>,\n): Promise<Pool<C, MS>[]> => {\n  let entries: [StorageKey<[u128]>, Option<ZeitgeistPrimitivesPool>][]\n\n  if (query && isPaginated(query)) {\n    const keys = query.keys ?? (await ctx.api.query.swaps.pools.keys())\n    entries = await ctx.api.query.swaps.pools.entriesPaged({\n      args: [],\n      pageSize: query.limit,\n      startKey: keys[query.offset].toHex(),\n    })\n  } else {\n    entries = await ctx.api.query.swaps.pools.entries()\n  }\n\n  return fromEntries<C, MS>(ctx, entries)\n}\n"],"names":[],"mappings":";;;;;AAiBA;;;;;;;;AAQG;AACU,MAAA,SAAS,GAAG,OACvB,OAAU,EACV,KAA4B,KACA;IAC5B,MAAM,KAAK,GACT,aAAa,CAAK,OAAO,CAAC,IAAI,gBAAgB,CAAK,OAAO,CAAC;AACzD,UAAE,MAAM,eAAe,CAAqB,OAAO,EAAE,KAAK,CAAC;AAC3D,UAAE,YAAY,CAAK,OAAO,CAAC;AAC3B,cAAE,MAAM,WAAW,CAAqB,OAAO,EAAE,KAAK,CAAC;cACrD,IAAI,CAAA;AAEV,IAAA,IAAI,MAAM,CAAC,KAAK,CAAC,EAAE;AACjB,QAAA,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAA;AAC7D,KAAA;AAED,IAAA,OAAO,KAAwB,CAAA;AACjC,EAAC;AAED;;;AAGG;AACH,MAAM,eAAe,GAAG,OACtB,OAAU,EACV,KAA4B,KACF;AAC1B,IAAA,OAAO,CAAC,MAAM,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,KAAsB,CAAA;AACpE,CAAC,CAAA;AAED;;;AAGG;AACH,MAAM,WAAW,GAAG,OAClB,GAAM,EACN,KAA6B,KACH;AAC1B,IAAA,IAAI,OAAgE,CAAA;AAEpE,IAAA,IAAI,KAAK,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE;QAC/B,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAA;AACnE,QAAA,OAAO,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC;AACrD,YAAA,IAAI,EAAE,EAAE;YACR,QAAQ,EAAE,KAAK,CAAC,KAAK;YACrB,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE;AACrC,SAAA,CAAC,CAAA;AACH,KAAA;AAAM,SAAA;AACL,QAAA,OAAO,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,CAAA;AACpD,KAAA;AAED,IAAA,OAAO,WAAW,CAAQ,GAAG,EAAE,OAAO,CAAC,CAAA;AACzC,CAAC;;;;"}
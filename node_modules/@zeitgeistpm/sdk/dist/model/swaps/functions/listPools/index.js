'use strict';

var util = require('@polkadot/util');
var types = require('../../../../context/types.js');
var pagination = require('../../../../primitives/pagination.js');
var pool = require('../../pool.js');

/**
 * Query for a list of pools.
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query in
 * @param query ListQuery<C>
 * @returns Promise<PoolList<C>>
 */
const listPools = async (context, query) => {
    const pools = types.isFullContext(context) || types.isIndexerContext(context)
        ? await listFromIndexer(context, query)
        : types.isRpcContext(context)
            ? await listFromRpc(context, query)
            : null;
    if (util.isNull(pools)) {
        throw new Error('No pools. Should be unreachable code path');
    }
    return pools;
};
/**
 * Concrete listing function for indexer context
 * @private
 */
const listFromIndexer = async (context, query) => {
    return (await context.indexer.pools(query)).pools;
};
/**
 * Concrete listing function for rpc context
 * @private
 */
const listFromRpc = async (ctx, query) => {
    let entries;
    if (query && pagination.isPaginated(query)) {
        const keys = query.keys ?? (await ctx.api.query.swaps.pools.keys());
        entries = await ctx.api.query.swaps.pools.entriesPaged({
            args: [],
            pageSize: query.limit,
            startKey: keys[query.offset].toHex(),
        });
    }
    else {
        entries = await ctx.api.query.swaps.pools.entries();
    }
    return pool.fromEntries(ctx, entries);
};

exports.listPools = listPools;
//# sourceMappingURL=index.js.map

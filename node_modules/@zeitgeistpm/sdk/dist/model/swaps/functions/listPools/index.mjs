import { isNull } from '@polkadot/util';
import { isFullContext, isIndexerContext, isRpcContext } from '../../../../context/types.mjs';
import { isPaginated } from '../../../../primitives/pagination.mjs';
import { fromEntries } from '../../pool.mjs';

/**
 * Query for a list of pools.
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query in
 * @param query ListQuery<C>
 * @returns Promise<PoolList<C>>
 */
const listPools = async (context, query) => {
    const pools = isFullContext(context) || isIndexerContext(context)
        ? await listFromIndexer(context, query)
        : isRpcContext(context)
            ? await listFromRpc(context, query)
            : null;
    if (isNull(pools)) {
        throw new Error('No pools. Should be unreachable code path');
    }
    return pools;
};
/**
 * Concrete listing function for indexer context
 * @private
 */
const listFromIndexer = async (context, query) => {
    return (await context.indexer.pools(query)).pools;
};
/**
 * Concrete listing function for rpc context
 * @private
 */
const listFromRpc = async (ctx, query) => {
    let entries;
    if (query && isPaginated(query)) {
        const keys = query.keys ?? (await ctx.api.query.swaps.pools.keys());
        entries = await ctx.api.query.swaps.pools.entriesPaged({
            args: [],
            pageSize: query.limit,
            startKey: keys[query.offset].toHex(),
        });
    }
    else {
        entries = await ctx.api.query.swaps.pools.entries();
    }
    return fromEntries(ctx, entries);
};

export { listPools };
//# sourceMappingURL=index.mjs.map

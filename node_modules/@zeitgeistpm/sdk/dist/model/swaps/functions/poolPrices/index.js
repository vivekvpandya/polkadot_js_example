'use strict';

var Indexer = require('@zeitgeistpm/indexer');
var array = require('@zeitgeistpm/utility/dist/array');
var Time = require('@zeitgeistpm/utility/dist/time');
var Decimal = require('decimal.js');
var rxjs = require('rxjs');
var types = require('../../../../context/types.js');
var assetid = require('../../../../primitives/assetid.js');
var index = require('../../../time/functions/now/index.js');

/**
 * Fetch poolprices for a cetain timespan. Will prefer indexer but use rpc if indexer isnt available.
 *
 * @generic C extends Context
 * @param context C
 * @param query PoolPricesQuery
 * @returns Promise<PoolPrices>
 */
const poolPrices = async (context, query) => {
    const data = types.isFullContext(context) || types.isIndexerContext(context)
        ? await indexerPoolPrices(context, query)
        : await rpcPoolPrices(context, query);
    return data;
};
/**
 * Fetch poolprices for a cetain timespan from rpc.
 *
 * @private
 * @param context RpcContext
 * @param query PoolPricesQuery
 * @returns Promise<PoolPrices>
 */
const rpcPoolPrices = async (ctx, query) => {
    const time = await index.now(ctx);
    const [pool, { start, end }] = await Promise.all([
        ctx.api.query.swaps.pools(query.pool).then(o => o.unwrap()),
        Time.asBlocks(time, query.timespan),
    ]);
    const ztg = { Ztg: null };
    let blocks = array.range(start, end);
    if (query.resolution) {
        const step = Time.asMs(query.resolution) / time.period;
        blocks = array.project(blocks, step);
    }
    const assets = pool.assets.toArray().slice(0, -1);
    const prices = await Promise.all(assets.map(async (asset) => {
        console.log('FOOOO');
        const prices = await ctx.api.rpc.swaps.getSpotPrices(query.pool, ztg, asset, blocks);
        console.log('BAAR');
        return array.zip(blocks, prices.map(price => new Decimal.Decimal(price.toString())));
    }));
    return prices;
};
/**
 * Fetch poolprices for a cetain timespan from indexer.
 *
 * @private
 * @param context IndexerContext
 * @param query PoolPricesQuery
 * @returns Promise<PoolPrices>
 */
const indexerPoolPrices = async (context, query) => {
    const { assets } = await context.indexer.assets({
        where: {
            poolId_eq: query.pool,
        },
    });
    const { historicalAssets } = await context.indexer.historicalAssets({
        order: [Indexer.HistoricalAssetOrderByInput.BlockNumberAsc],
        where: {
            assetId_in: assets.map(id => id.assetId),
            ...(Time.isBlocks(query.timespan)
                ? {
                    blockNumber_gte: query.timespan.start,
                    blockNumber_lte: query.timespan.end,
                }
                : {
                    timestamp_gte: query.timespan.start,
                    timestamp_lte: query.timespan.end,
                }),
        },
    });
    let prices = [];
    for (const record of historicalAssets) {
        if (!record.newPrice)
            continue;
        const assetId = JSON.parse(record.assetId);
        if (!assetid.IOAssetId.is(assetId)) {
            console.warn('found wrongly formated asset id', assetId);
            continue;
        }
        const index = assetid.getIndexOf(assetId);
        if (index === null) {
            continue;
        }
        prices[index] = [
            ...(prices[index] || []),
            [record.blockNumber, new Decimal.Decimal(record.newPrice * 10 ** 10)],
        ];
    }
    return prices;
};
/**
 * Will stream prices for a given pool tailed after a block or date.
 * Will emit the price at each block in the stream as dictated by the resolution passed.
 * When it reaches the end it starts to listen for new blocks and emits an item for every block.
 *
 * @param ctx RpcContext
 * @param query PoolPricesStreamQuery
 * @returns Observable<PoolAssetPricesAtBlock>
 */
const observePoolPrices$ = (ctx, query) => {
    return new rxjs.Observable(sub => {
        const unsub = Promise.all([
            ctx.api.query.swaps.pools(query.pool).then(o => o.unwrap()),
            index.now(ctx),
        ]).then(async ([pool, now]) => {
            const assets = pool.assets.toArray().slice(0, -1);
            if (query.from) {
                const head = await rpcPoolPrices(ctx, {
                    pool: query.pool,
                    resolution: query.resolution,
                    timespan: {
                        start: Time.asBlock(now, query.from),
                        end: now.block,
                    },
                });
                head[0].forEach((_, index) => sub.next(head.map(prices => prices[index])));
            }
            return ctx.api.rpc.chain.subscribeFinalizedHeads(async (header) => {
                const block = header.number.toNumber();
                const prices = await Promise.all(assets.map(async (asset) => {
                    const [price] = await ctx.api.rpc.swaps.getSpotPrices(query.pool, query.assetIn ?? { Ztg: null }, asset, [block]);
                    return [block, new Decimal.Decimal(price.toString())];
                }));
                sub.next(prices);
            });
        });
        return () => {
            unsub.then(unsub => unsub());
            sub.unsubscribe();
        };
    });
};

exports.observePoolPrices$ = observePoolPrices$;
exports.poolPrices = poolPrices;
//# sourceMappingURL=index.js.map

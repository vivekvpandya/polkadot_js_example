'use strict';

var util = require('@polkadot/util');
var rpc = require('@zeitgeistpm/rpc');
var assert = require('@zeitgeistpm/utility/dist/assert');
var E = require('@zeitgeistpm/utility/dist/either');
var error = require('@zeitgeistpm/utility/dist/error');
var O = require('@zeitgeistpm/utility/dist/option');
var Te = require('@zeitgeistpm/utility/dist/taskeither');
var Time = require('@zeitgeistpm/utility/dist/time');
var CID = require('cids');
var Decimal = require('decimal.js');
var index$2 = require('../swaps/functions/getPool/index.js');
require('@zeitgeistpm/indexer');
require('@zeitgeistpm/utility/dist/array');
require('rxjs');
var types$1 = require('../../context/types.js');
require('../../primitives/assetid.js');
var index$1 = require('../time/functions/now/index.js');
var ztg = require('../../primitives/ztg.js');
require('../../primitives/blocknumber.js');
require('../../primitives/marketid.js');
var data = require('../../primitives/data.js');
var na = require('../../primitives/na.js');
var index = require('./functions/create/index.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var E__namespace = /*#__PURE__*/_interopNamespaceDefault(E);
var O__namespace = /*#__PURE__*/_interopNamespaceDefault(O);
var Te__namespace = /*#__PURE__*/_interopNamespaceDefault(Te);

/**
 * Typeguard to check if market has associated marketmethods.
 *
 * @param market Market<C, MS>
 * @returns market is Market<C, MS> & MarketMethods
 */
const hasMarketMethods = (market) => 'deploySwapPool' in market;
/**
 * Augment a market primitive with id and data expanding utility functions.
 *
 * @param context RpcContext
 * @param id u128
 * @param primitive ZeitgeistPrimitivesMarket
 * @returns AugmentedAugmentedRpcMarket
 */
const rpcMarket = (context, id, primitive) => {
    let market = primitive;
    market.marketId = util.isNumber(id) ? id : id.toNumber();
    market.fetchMetadata = Te__namespace.from(async () => {
        const hex = market.metadata.toHex();
        const cid = new CID('f0155' + hex.slice(2));
        const id = { __meta: 'markets', cid: cid };
        const metadata = await context.storage.of('markets').get(id);
        return metadata.unwrapOr(error.throwsC(Error(`could not fetch metadata for market: ${market.marketId}`)));
    });
    market.fetchDisputes = Te__namespace.from(async () => {
        const disputes = await context.api.query.predictionMarkets.disputes(id);
        return disputes.toArray();
    });
    market.saturate = Te__namespace.from(async () => {
        const [metadata, pool] = await Promise.all([
            market.fetchMetadata(),
            context.api.query.marketCommons.marketPool(market.marketId).then(id => {
                if (id.isSome) {
                    return context.api.query.swaps.pools(id.unwrap()).then(p => p.unwrapOr(null));
                }
            }),
        ]);
        const outcomeAssets = pool ? pool.assets.toArray().map(a => JSON.stringify(a)) : [];
        const base = {
            id: `${market.marketId}`,
            marketId: market.marketId,
            creation: primitive.creation.type,
            creator: primitive.creator.toHuman(),
            oracle: primitive.oracle.toHuman(),
            deadlines: primitive.deadlines,
            creatorFee: primitive.creatorFee.toNumber(),
            scoringRule: primitive.scoringRule.type,
            outcomeAssets: outcomeAssets,
            status: primitive.status.toString(),
            period: primitive.period.toHuman(),
            marketType: primitive.marketType.toHuman(),
            disputeMechanism: primitive.disputeMechanism.toHuman(),
            report: primitive.report.toHuman(),
            resolvedOutcome: primitive.resolvedOutcome.toHuman(),
        };
        let saturatedRpcMarket = {
            ...base,
            ...metadata,
        };
        attachMarketMethods(context, saturatedRpcMarket);
        return saturatedRpcMarket;
    });
    market = attachMarketMethods(context, market);
    return market;
};
/**
 * Attach transaction interfaces for deploying pool etc to market.
 *
 * @param context Context<MS>
 * @param market Market<C, MS>
 * @returns Market<C, MS>
 */
const attachMarketMethods = (context, market) => {
    if (types$1.isRpcContext(context)) {
        let marketWithMethods = market;
        marketWithMethods.deploySwapPool = Te__namespace.from(async (params) => {
            assert.assert(!(await hasPool(context, market)), () => {
                throw new Error('Cannot deploy pool for market that allready has pool.');
            });
            const tx = context.api.tx.predictionMarkets.deploySwapPoolForMarket(market.marketId, params.swapFee, params.amount, params.weights);
            const extrinsic = await rpc.signAndSend({
                api: context.api,
                tx,
                signer: params.signer,
                hooks: params.hooks,
            });
            const pool = index.extractPoolCreationEventForMarket(context, extrinsic.events, market.marketId);
            return pool.unwrap();
        });
        marketWithMethods.deploySwapPoolAndAdditionalLiquidity = Te__namespace.from(async (params) => {
            assert.assert(!(await hasPool(context, market)), () => {
                throw new Error('Cannot deploy pool for market that allready has pool.');
            });
            const tx = context.api.tx.predictionMarkets.deploySwapPoolAndAdditionalLiquidity(market.marketId, params.swapFee, params.amount, params.weights);
            const extrinsic = await rpc.signAndSend({
                api: context.api,
                tx,
                signer: params.signer,
                hooks: params.hooks,
            });
            const pool = index.extractPoolCreationEventForMarket(context, extrinsic.events, market.marketId);
            return pool.unwrap();
        });
        marketWithMethods.buyCompleteSet = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.buyCompleteSet(market.marketId, params.amount),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.sellCompleteSet = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.sellCompleteSet(market.marketId, params.amount),
                signer: params.signer,
            });
        });
        marketWithMethods.redeemShares = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.redeemShares(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.disputeOutcome = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.dispute(market.marketId, params.outcome),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.reportOutcome = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.report(market.marketId, params.outcome),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminDestroyMarket = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.adminDestroyMarket(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminMoveMarketToClosed = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.adminMoveMarketToClosed(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminMoveMarketToResolved = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.adminMoveMarketToResolved(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.approveMarket = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.approveMarket(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminCleanUpPool = Te__namespace.from(async (params) => {
            return await rpc.signAndSend({
                api: context.api,
                tx: context.api.tx.swaps.adminCleanUpPool(market.marketId, params.outcome),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        return marketWithMethods;
    }
    return market;
};
/**
 * Get the pool id of a market in a way to works for both indexed and rpc data.
 *
 * @param market Market<C, MS>
 * @returns Promise<O.IOption<number>>
 */
const getPoolId = async (context, market) => {
    if (data.isIndexedData(market)) {
        return market.pool?.poolId ? O__namespace.option(O__namespace.some(market.pool?.poolId)) : O__namespace.option(O__namespace.none());
    }
    else {
        if (types$1.isRpcContext(context)) {
            const pool = await context.api.query.marketCommons.marketPool(market.marketId);
            return pool.isSome ? O__namespace.option(O__namespace.some(pool.unwrap().toNumber())) : O__namespace.option(O__namespace.none());
        }
        else {
            const { pools: [pool], } = await context.indexer.pools({
                where: {
                    marketId_eq: market.marketId,
                },
            });
            return pool ? O__namespace.option(O__namespace.some(pool.poolId)) : O__namespace.option(O__namespace.none());
        }
    }
};
/**
 * Check if a rpc or indexed market has pool associated.
 *
 * @param market Market<C, MS>
 * @returns Promise<boolean>
 */
const hasPool = async (context, market) => {
    return O__namespace.isSome(await getPoolId(context, market));
};
/**
 * Get the market status.
 *
 * @param market Market<Context>
 * @returns MarketStatus
 */
const getStatus = (market) => {
    return data.isRpcData(market)
        ? market.status.type
        : market.status;
};
/**
 * Get the market deadlines.
 *
 * @param market Market<Context>
 * @returns MarketDeadlines
 */
const getDeadlines = (market) => {
    if (data.isRpcData(market)) {
        return {
            gracePeriod: market.deadlines.gracePeriod.toNumber(),
            oracleDuration: market.deadlines.oracleDuration.toNumber(),
            disputeDuration: market.deadlines.disputeDuration.toNumber(),
        };
    }
    return {
        gracePeriod: Number(market.deadlines?.gracePeriod ?? 0),
        oracleDuration: Number(market.deadlines?.oracleDuration ?? 0),
        disputeDuration: Number(market.deadlines?.disputeDuration ?? 0),
    };
};
/**
 * Get the market period as a Timespan.
 *
 * @param market Market<Context>
 * @param now ChainTime
 * @returns Timespan
 */
const timespanOf = (market, now) => {
    if (data.isRpcData(market)) {
        const start = market.period.isTimestamp
            ? market.period.asTimestamp.start.toNumber()
            : Time.blockDate(now, market.period.asBlock.start.toNumber());
        const end = market.period.isTimestamp
            ? market.period.asTimestamp.end.toNumber()
            : Time.blockDate(now, market.period.asBlock.end.toNumber());
        return { start, end };
    }
    return {
        start: new Date(market.period.start),
        end: new Date(market.period.end),
    };
};
/**
 * Check if a market has a report.
 *
 * @param market Market<Context>
 * @returns boolean
 */
const hasReport = (market) => {
    return data.isRpcData(market) ? market.report.isSome : !!market.report;
};
/**
 * Get the market reporter address if market is reported.
 *
 * @param market Market<Context>
 * @returns O.IOption<string>
 */
const getReporter = (market) => {
    return O__namespace.fromNullable(data.isRpcData(market) ? market.report.unwrapOr(null)?.by.toString() : market.report?.by);
};
/**
 * Get the market reported at block if market is reported.
 *
 * @param market Market<Context>
 * @returns O.IOption<number>
 */
const getReportedAt = (market) => {
    return O__namespace.fromNullable(data.isRpcData(market) ? market.report.unwrapOr(null)?.at.toNumber() : market.report?.at);
};
/**
 * Get the projected end timestamp for a market.
 *
 * @note If market has period as timestamps will use that directly and if its set to a block end date
 * it will project a approximate end timestamp based on the on chain current block and block time.
 *
 * @param context Context<MS>
 * @param market Market<C, MS>
 * @returns Promise<number | NA>
 */
const projectEndTimestamp = async (ctx, market, _now) => {
    const chainTime = types$1.isRpcContext(ctx) ? await (_now ?? index$1.now(ctx)) : null;
    if (data.isRpcData(market)) {
        if (market.period.isTimestamp) {
            return market.period.asTimestamp.end.toNumber();
        }
        else if (chainTime) {
            const endBlock = Number(market.period.asBlock[1].toHuman());
            return Time.blockDate(chainTime, endBlock).getTime();
        }
    }
    else {
        if (market.period.timestamp) {
            return Number(market.period.timestamp[1]);
        }
        else if (chainTime) {
            const endBlock = market.period.block[1];
            return Time.blockDate(chainTime, endBlock).getTime();
        }
    }
    return na.NA;
};
/**
 * Get scalar market bounds.
 *
 * @param market Market<Context>
 * @returns E.IEither<Error, [Decimal, Decimal]>
 */
const getScalarBounds = (market) => {
    if (data.isRpcData(market)) {
        if (!market.marketType.isScalar)
            return E__namespace.either(E__namespace.left(new Error('Not a scalar market')));
        const bounds = market.marketType.asScalar;
        return E__namespace.either(E__namespace.right([
            new Decimal(bounds[0].toString()).div(ztg.ZTG),
            new Decimal(bounds[1].toString()).div(ztg.ZTG),
        ]));
    }
    else {
        if (!market.marketType.scalar)
            return E__namespace.either(E__namespace.left(new Error('Not a scalar market')));
        const bounds = market.marketType.scalar;
        return E__namespace.either(E__namespace.right([new Decimal(bounds[0]).div(ztg.ZTG), new Decimal(bounds[1]).div(ztg.ZTG)]));
    }
};
/**
 *
 *
 * @param ctx Context<MS>
 * @param market Market<C>
 */
const getPrediction = async (ctx, market) => {
    if (data.isRpcData(market)) {
        if (market.status.type === 'Resolved') {
            const report = market.report.unwrap();
            report.outcome.toNumber();
            (await index$2.getPool(ctx, market)).unwrap();
        }
    }
};

exports.attachMarketMethods = attachMarketMethods;
exports.getDeadlines = getDeadlines;
exports.getPoolId = getPoolId;
exports.getPrediction = getPrediction;
exports.getReportedAt = getReportedAt;
exports.getReporter = getReporter;
exports.getScalarBounds = getScalarBounds;
exports.getStatus = getStatus;
exports.hasMarketMethods = hasMarketMethods;
exports.hasPool = hasPool;
exports.hasReport = hasReport;
exports.projectEndTimestamp = projectEndTimestamp;
exports.rpcMarket = rpcMarket;
exports.timespanOf = timespanOf;
//# sourceMappingURL=market.js.map

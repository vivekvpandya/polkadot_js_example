import type { u128 } from '@polkadot/types';
import { ZeitgeistPrimitivesMarket, ZeitgeistPrimitivesMarketMarketDispute, ZeitgeistPrimitivesMarketMarketStatus } from '@polkadot/types/lookup';
import type { ISubmittableResult } from '@polkadot/types/types';
import type { FullMarketFragment } from '@zeitgeistpm/indexer';
import { KeyringPairOrExtSigner, TransactionError, TransactionHooks } from '@zeitgeistpm/rpc';
import * as E from '@zeitgeistpm/utility/dist/either';
import * as O from '@zeitgeistpm/utility/dist/option';
import * as Te from '@zeitgeistpm/utility/dist/taskeither';
import { ChainTime, Timespan } from '@zeitgeistpm/utility/dist/time';
import Decimal from 'decimal.js';
import { Context, FullContext, IndexerContext, RpcContext } from '../../context';
import { MarketTypeOf, MetadataStorage } from '../../meta';
import { MarketMetadata } from '../../meta/market';
import { Data, NA } from '../../primitives';
import { ExchangeFullSetParams, PoolDeploymentParams, RpcPool } from '../types';
import { ReportOutcomeParams } from './outcome';
export * from './functions/create/types';
export * from './functions/list/types';
/**
 * Union type for Indexed and Rpc Markets.
 */
export declare type Market<C extends Context<MS>, MS extends MetadataStorage = MetadataStorage> = Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends FullContext<MS> | IndexerContext ? IndexedMarket<C, MS> : never, MS>;
/**
 * Concrete Market type for a indexed market.
 */
export declare type IndexedMarket<C extends Context<MS>, MS extends MetadataStorage = MetadataStorage> = FullMarketFragment & (C extends RpcContext<MS> ? MarketMethods : {});
/**
 * Concrete Market type for a rpc market.
 */
export declare type RpcMarket<C extends RpcContext<MS>, MS extends MetadataStorage = MetadataStorage> = ZeitgeistPrimitivesMarket & MarketMethods & {
    /**
     * Market id/index. Set for conformity and convenince when fetching markets from rpc.
     */
    marketId: number;
    /**
     * Fetch metadata from external storage(default IPFS).
     */
    fetchMetadata: Te.TaskEither<Error, MarketTypeOf<MS>, []>;
    /**
     * Conform a rpc market to a indexed market type by fetching metadata, poolid from external storage(default IPFS) and decoding data.
     */
    saturate: Te.TaskEither<Error, SaturatedRpcMarket<C, MS>, []>;
    /**
     * Fetch disputes for the market.
     */
    fetchDisputes: Te.TaskEither<Error, ZeitgeistPrimitivesMarketMarketDispute[], []>;
};
export declare type SaturatedRpcMarket<C extends RpcContext<MS>, MS extends MetadataStorage> = IndexedBase & MarketTypeOf<MS> & RpcMarket<C, MS>;
/**
 * The base type of indexed data that also can be infered from the rpc data.
 */
export declare type IndexedBase = Omit<FullMarketFragment, keyof MarketMetadata>;
/**
 * Interface on market with methods for deploying swap pools, buying and selling sets of assets..
 */
export declare type MarketMethods = {
    /**
     * Deploy a swap pool for the market.
     *
     * @param params Omit<PoolDeploymentParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, RpcPool>>
     */
    deploySwapPool: Te.TaskEither<TransactionError, RpcPool, [
        params: Omit<PoolDeploymentParams, 'marketId'> & TransactionHooks
    ]>;
    /**
     * Deploy a swap pool for the market and add liquidity.
     *
     * @param params Omit<PoolDeploymentParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, RpcPool>>
     */
    deploySwapPoolAndAdditionalLiquidity: Te.TaskEither<TransactionError, RpcPool, [
        params: Omit<PoolDeploymentParams, 'marketId'> & TransactionHooks
    ]>;
    /**
     * Buy a full set of market assets.
     *
     * @param params Omit<ExchangeFullSetParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    buyCompleteSet: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<ExchangeFullSetParams, 'marketId'> & TransactionHooks
    ]>;
    /**
     * Sell a full set of market assets.
     *
     * @param params Omit<ExchangeFullSetParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    sellCompleteSet: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<ExchangeFullSetParams, 'marketId'> & TransactionHooks
    ]>;
    /**
     * Redeem the shares for a market.
     *
     * @param params { signer: KeyringPairOrExtSigner } & TransactionHooks
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    redeemShares: Te.TaskEither<Error, ISubmittableResult, [
        params: {
            signer: KeyringPairOrExtSigner;
        } & TransactionHooks
    ]>;
    /**
     * Dispute the current market outcome with a proposed new outcome.
     *
     * @param params Omit<ReportOutcomeParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    disputeOutcome: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<ReportOutcomeParams, 'marketId'> & TransactionHooks
    ]>;
    /**
     * Report the outcome of a market. Can only be called by the markets oracle address.
     *
     * @param params Omit<ReportOutcomeParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    reportOutcome: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<ReportOutcomeParams, 'marketId'> & TransactionHooks
    ]>;
    /**
     * Destroy a market, including its outcome assets, market account and pool account.
     *
     * Must be called by `DestroyOrigin`. Bonds (unless already returned) are slashed without
     * exception. Can currently only be used for destroying CPMM markets.
     *
     * @origin DestroyOrigin
     * @param params {signer: KeyringPairOrExtSigner}
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    adminDestroyMarket: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: {
            signer: KeyringPairOrExtSigner;
        } & TransactionHooks
    ]>;
    /**
     * Immediately move an open market to closed.
     *
     * @origin CloseOrigin
     * @param signer {signer: KeyringPairOrExtSigner}
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    adminMoveMarketToClosed: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: {
            signer: KeyringPairOrExtSigner;
        } & TransactionHooks
    ]>;
    /**
     * Immediately move a reported or disputed market to resolved.
     *
     * @origin ResolveOrigin
     * @param signer {signer: KeyringPairOrExtSigner}
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    adminMoveMarketToResolved: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: {
            signer: KeyringPairOrExtSigner;
        } & TransactionHooks
    ]>;
    /**
     * Approves a market that is waiting for approval from the
     * advisory committee.
     *
     * @origin ApproveOrigin
     * @param signer {signer: KeyringPairOrExtSigner}
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    approveMarket: Te.TaskEither<Error, ISubmittableResult, [
        params: {
            signer: KeyringPairOrExtSigner;
        } & TransactionHooks
    ]>;
    /**
     * Clean up the pool of a resolved market.
     *
     * @origin The root origin.
     * @param params Omit<ReportOutcomeParams, 'marketId'>
     * @returns Promise<EitherInterface<Error, ISubmittableResult>>
     */
    adminCleanUpPool: Te.TaskEither<TransactionError, ISubmittableResult, [
        params: Omit<ReportOutcomeParams, 'marketId'> & TransactionHooks
    ]>;
};
/**
 * Union type of all market statuses as string.
 */
export declare type MarketStatus = ZeitgeistPrimitivesMarketMarketStatus['type'] | 'Destroyed';
/**
 * Type for market deadlines as numbers.
 */
export declare type MarketDeadlines = {
    gracePeriod: number;
    oracleDuration: number;
    disputeDuration: number;
};
/**
 * Typeguard to check if market has associated marketmethods.
 *
 * @param market Market<C, MS>
 * @returns market is Market<C, MS> & MarketMethods
 */
export declare const hasMarketMethods: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata> = MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(market: Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>) => market is Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS> & MarketMethods;
/**
 * Augment a market primitive with id and data expanding utility functions.
 *
 * @param context RpcContext
 * @param id u128
 * @param primitive ZeitgeistPrimitivesMarket
 * @returns AugmentedAugmentedRpcMarket
 */
export declare const rpcMarket: <C extends RpcContext<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(context: C, id: u128 | number, primitive: ZeitgeistPrimitivesMarket) => Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>;
/**
 * Attach transaction interfaces for deploying pool etc to market.
 *
 * @param context Context<MS>
 * @param market Market<C, MS>
 * @returns Market<C, MS>
 */
export declare const attachMarketMethods: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(context: C, market: Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>) => Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>;
/**
 * Get the pool id of a market in a way to works for both indexed and rpc data.
 *
 * @param market Market<C, MS>
 * @returns Promise<O.IOption<number>>
 */
export declare const getPoolId: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata> = MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(context: C, market: Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>) => Promise<O.IOption<number>>;
/**
 * Check if a rpc or indexed market has pool associated.
 *
 * @param market Market<C, MS>
 * @returns Promise<boolean>
 */
export declare const hasPool: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata> = MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(context: C, market: Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>) => Promise<boolean>;
/**
 * Get the market status.
 *
 * @param market Market<Context>
 * @returns MarketStatus
 */
export declare const getStatus: (market: Market<Context>) => MarketStatus;
/**
 * Get the market deadlines.
 *
 * @param market Market<Context>
 * @returns MarketDeadlines
 */
export declare const getDeadlines: (market: Market<Context>) => MarketDeadlines;
/**
 * Get the market period as a Timespan.
 *
 * @param market Market<Context>
 * @param now ChainTime
 * @returns Timespan
 */
export declare const timespanOf: (market: Market<Context>, now: ChainTime) => Timespan;
/**
 * Check if a market has a report.
 *
 * @param market Market<Context>
 * @returns boolean
 */
export declare const hasReport: (market: Market<Context>) => boolean;
/**
 * Get the market reporter address if market is reported.
 *
 * @param market Market<Context>
 * @returns O.IOption<string>
 */
export declare const getReporter: (market: Market<Context>) => O.IOption<string>;
/**
 * Get the market reported at block if market is reported.
 *
 * @param market Market<Context>
 * @returns O.IOption<number>
 */
export declare const getReportedAt: (market: Market<Context>) => O.IOption<number>;
/**
 * Get the projected end timestamp for a market.
 *
 * @note If market has period as timestamps will use that directly and if its set to a block end date
 * it will project a approximate end timestamp based on the on chain current block and block time.
 *
 * @param context Context<MS>
 * @param market Market<C, MS>
 * @returns Promise<number | NA>
 */
export declare const projectEndTimestamp: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(ctx: C, market: Data<C, C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never, C extends IndexerContext | FullContext<MS> ? IndexedMarket<C, MS> : never, MS>, _now?: ChainTime) => Promise<number | NA>;
/**
 * Get scalar market bounds.
 *
 * @param market Market<Context>
 * @returns E.IEither<Error, [Decimal, Decimal]>
 */
export declare const getScalarBounds: (market: Market<Context>) => E.IEither<Error, [Decimal, Decimal]>;
/**
 *
 *
 * @param ctx Context<MS>
 * @param market Market<C>
 */
export declare const getPrediction: <C extends Context<MS>, MS extends MetadataStorage<{
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, import("../../meta").CommentMetadata>>(ctx: C, market: Market<Context>) => Promise<void>;
//# sourceMappingURL=market.d.ts.map
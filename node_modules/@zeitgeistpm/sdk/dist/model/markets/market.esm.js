import { isNumber } from '@polkadot/util';
import { signAndSend } from '@zeitgeistpm/rpc';
import { assert } from '@zeitgeistpm/utility/dist/assert';
import * as E from '@zeitgeistpm/utility/dist/either';
import { throwsC } from '@zeitgeistpm/utility/dist/error';
import * as O from '@zeitgeistpm/utility/dist/option';
import * as Te from '@zeitgeistpm/utility/dist/taskeither';
import { blockDate } from '@zeitgeistpm/utility/dist/time';
import CID from 'cids';
import Decimal from 'decimal.js';
import { getPool } from '../swaps/functions/getPool/index.esm.js';
import '@zeitgeistpm/indexer';
import '@zeitgeistpm/utility/dist/array';
import 'rxjs';
import { isRpcContext } from '../../context/types.esm.js';
import '../../primitives/assetid.esm.js';
import { now } from '../time/functions/now/index.esm.js';
import { ZTG } from '../../primitives/ztg.esm.js';
import '../../primitives/blocknumber.esm.js';
import '../../primitives/marketid.esm.js';
import { isIndexedData, isRpcData } from '../../primitives/data.esm.js';
import { NA } from '../../primitives/na.esm.js';
import { extractPoolCreationEventForMarket } from './functions/create/index.esm.js';

/**
 * Typeguard to check if market has associated marketmethods.
 *
 * @param market Market<C, MS>
 * @returns market is Market<C, MS> & MarketMethods
 */
const hasMarketMethods = (market) => 'deploySwapPool' in market;
/**
 * Augment a market primitive with id and data expanding utility functions.
 *
 * @param context RpcContext
 * @param id u128
 * @param primitive ZeitgeistPrimitivesMarket
 * @returns AugmentedAugmentedRpcMarket
 */
const rpcMarket = (context, id, primitive) => {
    let market = primitive;
    market.marketId = isNumber(id) ? id : id.toNumber();
    market.fetchMetadata = Te.from(async () => {
        const hex = market.metadata.toHex();
        const cid = new CID('f0155' + hex.slice(2));
        const id = { __meta: 'markets', cid: cid };
        const metadata = await context.storage.of('markets').get(id);
        return metadata.unwrapOr(throwsC(Error(`could not fetch metadata for market: ${market.marketId}`)));
    });
    market.fetchDisputes = Te.from(async () => {
        const disputes = await context.api.query.predictionMarkets.disputes(id);
        return disputes.toArray();
    });
    market.saturate = Te.from(async () => {
        const [metadata, pool] = await Promise.all([
            market.fetchMetadata(),
            context.api.query.marketCommons.marketPool(market.marketId).then(id => {
                if (id.isSome) {
                    return context.api.query.swaps.pools(id.unwrap()).then(p => p.unwrapOr(null));
                }
            }),
        ]);
        const outcomeAssets = pool ? pool.assets.toArray().map(a => JSON.stringify(a)) : [];
        const base = {
            id: `${market.marketId}`,
            marketId: market.marketId,
            creation: primitive.creation.type,
            creator: primitive.creator.toHuman(),
            oracle: primitive.oracle.toHuman(),
            deadlines: primitive.deadlines,
            creatorFee: primitive.creatorFee.toNumber(),
            scoringRule: primitive.scoringRule.type,
            outcomeAssets: outcomeAssets,
            status: primitive.status.toString(),
            period: primitive.period.toHuman(),
            marketType: primitive.marketType.toHuman(),
            disputeMechanism: primitive.disputeMechanism.toHuman(),
            report: primitive.report.toHuman(),
            resolvedOutcome: primitive.resolvedOutcome.toHuman(),
        };
        let saturatedRpcMarket = {
            ...base,
            ...metadata,
        };
        attachMarketMethods(context, saturatedRpcMarket);
        return saturatedRpcMarket;
    });
    market = attachMarketMethods(context, market);
    return market;
};
/**
 * Attach transaction interfaces for deploying pool etc to market.
 *
 * @param context Context<MS>
 * @param market Market<C, MS>
 * @returns Market<C, MS>
 */
const attachMarketMethods = (context, market) => {
    if (isRpcContext(context)) {
        let marketWithMethods = market;
        marketWithMethods.deploySwapPool = Te.from(async (params) => {
            assert(!(await hasPool(context, market)), () => {
                throw new Error('Cannot deploy pool for market that allready has pool.');
            });
            const tx = context.api.tx.predictionMarkets.deploySwapPoolForMarket(market.marketId, params.swapFee, params.amount, params.weights);
            const extrinsic = await signAndSend({
                api: context.api,
                tx,
                signer: params.signer,
                hooks: params.hooks,
            });
            const pool = extractPoolCreationEventForMarket(context, extrinsic.events, market.marketId);
            return pool.unwrap();
        });
        marketWithMethods.deploySwapPoolAndAdditionalLiquidity = Te.from(async (params) => {
            assert(!(await hasPool(context, market)), () => {
                throw new Error('Cannot deploy pool for market that allready has pool.');
            });
            const tx = context.api.tx.predictionMarkets.deploySwapPoolAndAdditionalLiquidity(market.marketId, params.swapFee, params.amount, params.weights);
            const extrinsic = await signAndSend({
                api: context.api,
                tx,
                signer: params.signer,
                hooks: params.hooks,
            });
            const pool = extractPoolCreationEventForMarket(context, extrinsic.events, market.marketId);
            return pool.unwrap();
        });
        marketWithMethods.buyCompleteSet = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.buyCompleteSet(market.marketId, params.amount),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.sellCompleteSet = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.sellCompleteSet(market.marketId, params.amount),
                signer: params.signer,
            });
        });
        marketWithMethods.redeemShares = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.redeemShares(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.disputeOutcome = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.dispute(market.marketId, params.outcome),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.reportOutcome = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.report(market.marketId, params.outcome),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminDestroyMarket = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.adminDestroyMarket(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminMoveMarketToClosed = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.adminMoveMarketToClosed(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminMoveMarketToResolved = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.adminMoveMarketToResolved(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.approveMarket = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.predictionMarkets.approveMarket(market.marketId),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        marketWithMethods.adminCleanUpPool = Te.from(async (params) => {
            return await signAndSend({
                api: context.api,
                tx: context.api.tx.swaps.adminCleanUpPool(market.marketId, params.outcome),
                signer: params.signer,
                hooks: params.hooks,
            });
        });
        return marketWithMethods;
    }
    return market;
};
/**
 * Get the pool id of a market in a way to works for both indexed and rpc data.
 *
 * @param market Market<C, MS>
 * @returns Promise<O.IOption<number>>
 */
const getPoolId = async (context, market) => {
    if (isIndexedData(market)) {
        return market.pool?.poolId ? O.option(O.some(market.pool?.poolId)) : O.option(O.none());
    }
    else {
        if (isRpcContext(context)) {
            const pool = await context.api.query.marketCommons.marketPool(market.marketId);
            return pool.isSome ? O.option(O.some(pool.unwrap().toNumber())) : O.option(O.none());
        }
        else {
            const { pools: [pool], } = await context.indexer.pools({
                where: {
                    marketId_eq: market.marketId,
                },
            });
            return pool ? O.option(O.some(pool.poolId)) : O.option(O.none());
        }
    }
};
/**
 * Check if a rpc or indexed market has pool associated.
 *
 * @param market Market<C, MS>
 * @returns Promise<boolean>
 */
const hasPool = async (context, market) => {
    return O.isSome(await getPoolId(context, market));
};
/**
 * Get the market status.
 *
 * @param market Market<Context>
 * @returns MarketStatus
 */
const getStatus = (market) => {
    return isRpcData(market)
        ? market.status.type
        : market.status;
};
/**
 * Get the market deadlines.
 *
 * @param market Market<Context>
 * @returns MarketDeadlines
 */
const getDeadlines = (market) => {
    if (isRpcData(market)) {
        return {
            gracePeriod: market.deadlines.gracePeriod.toNumber(),
            oracleDuration: market.deadlines.oracleDuration.toNumber(),
            disputeDuration: market.deadlines.disputeDuration.toNumber(),
        };
    }
    return {
        gracePeriod: Number(market.deadlines?.gracePeriod ?? 0),
        oracleDuration: Number(market.deadlines?.oracleDuration ?? 0),
        disputeDuration: Number(market.deadlines?.disputeDuration ?? 0),
    };
};
/**
 * Get the market period as a Timespan.
 *
 * @param market Market<Context>
 * @param now ChainTime
 * @returns Timespan
 */
const timespanOf = (market, now) => {
    if (isRpcData(market)) {
        const start = market.period.isTimestamp
            ? market.period.asTimestamp.start.toNumber()
            : blockDate(now, market.period.asBlock.start.toNumber());
        const end = market.period.isTimestamp
            ? market.period.asTimestamp.end.toNumber()
            : blockDate(now, market.period.asBlock.end.toNumber());
        return { start, end };
    }
    return {
        start: new Date(market.period.start),
        end: new Date(market.period.end),
    };
};
/**
 * Check if a market has a report.
 *
 * @param market Market<Context>
 * @returns boolean
 */
const hasReport = (market) => {
    return isRpcData(market) ? market.report.isSome : !!market.report;
};
/**
 * Get the market reporter address if market is reported.
 *
 * @param market Market<Context>
 * @returns O.IOption<string>
 */
const getReporter = (market) => {
    return O.fromNullable(isRpcData(market) ? market.report.unwrapOr(null)?.by.toString() : market.report?.by);
};
/**
 * Get the market reported at block if market is reported.
 *
 * @param market Market<Context>
 * @returns O.IOption<number>
 */
const getReportedAt = (market) => {
    return O.fromNullable(isRpcData(market) ? market.report.unwrapOr(null)?.at.toNumber() : market.report?.at);
};
/**
 * Get the projected end timestamp for a market.
 *
 * @note If market has period as timestamps will use that directly and if its set to a block end date
 * it will project a approximate end timestamp based on the on chain current block and block time.
 *
 * @param context Context<MS>
 * @param market Market<C, MS>
 * @returns Promise<number | NA>
 */
const projectEndTimestamp = async (ctx, market, _now) => {
    const chainTime = isRpcContext(ctx) ? await (_now ?? now(ctx)) : null;
    if (isRpcData(market)) {
        if (market.period.isTimestamp) {
            return market.period.asTimestamp.end.toNumber();
        }
        else if (chainTime) {
            const endBlock = Number(market.period.asBlock[1].toHuman());
            return blockDate(chainTime, endBlock).getTime();
        }
    }
    else {
        if (market.period.timestamp) {
            return Number(market.period.timestamp[1]);
        }
        else if (chainTime) {
            const endBlock = market.period.block[1];
            return blockDate(chainTime, endBlock).getTime();
        }
    }
    return NA;
};
/**
 * Get scalar market bounds.
 *
 * @param market Market<Context>
 * @returns E.IEither<Error, [Decimal, Decimal]>
 */
const getScalarBounds = (market) => {
    if (isRpcData(market)) {
        if (!market.marketType.isScalar)
            return E.either(E.left(new Error('Not a scalar market')));
        const bounds = market.marketType.asScalar;
        return E.either(E.right([
            new Decimal(bounds[0].toString()).div(ZTG),
            new Decimal(bounds[1].toString()).div(ZTG),
        ]));
    }
    else {
        if (!market.marketType.scalar)
            return E.either(E.left(new Error('Not a scalar market')));
        const bounds = market.marketType.scalar;
        return E.either(E.right([new Decimal(bounds[0]).div(ZTG), new Decimal(bounds[1]).div(ZTG)]));
    }
};
/**
 *
 *
 * @param ctx Context<MS>
 * @param market Market<C>
 */
const getPrediction = async (ctx, market) => {
    if (isRpcData(market)) {
        if (market.status.type === 'Resolved') {
            const report = market.report.unwrap();
            report.outcome.toNumber();
            (await getPool(ctx, market)).unwrap();
        }
    }
};

export { attachMarketMethods, getDeadlines, getPoolId, getPrediction, getReportedAt, getReporter, getScalarBounds, getStatus, hasMarketMethods, hasPool, hasReport, projectEndTimestamp, rpcMarket, timespanOf };
//# sourceMappingURL=market.esm.js.map

{"version":3,"file":"market.mjs","sources":["../../../src/model/markets/market.ts"],"sourcesContent":["import type { u128 } from '@polkadot/types'\nimport {\n  ZeitgeistPrimitivesMarket,\n  ZeitgeistPrimitivesMarketMarketDispute,\n  ZeitgeistPrimitivesMarketMarketStatus,\n} from '@polkadot/types/lookup'\nimport type { ISubmittableResult } from '@polkadot/types/types'\nimport { isNumber } from '@polkadot/util'\nimport type { FullMarketFragment } from '@zeitgeistpm/indexer'\nimport {\n  KeyringPairOrExtSigner,\n  signAndSend,\n  TransactionError,\n  TransactionHooks,\n} from '@zeitgeistpm/rpc'\nimport { assert } from '@zeitgeistpm/utility/dist/assert'\nimport * as E from '@zeitgeistpm/utility/dist/either'\nimport { throwsC } from '@zeitgeistpm/utility/dist/error'\nimport * as O from '@zeitgeistpm/utility/dist/option'\nimport * as Te from '@zeitgeistpm/utility/dist/taskeither'\nimport { blockDate, ChainTime, Timespan } from '@zeitgeistpm/utility/dist/time'\nimport CID from 'cids'\nimport Decimal from 'decimal.js'\nimport { getPool } from 'model/swaps/functions/getPool'\nimport { poolPrices } from 'model/swaps/functions/poolPrices'\nimport {\n  Context,\n  FullContext,\n  IndexerContext,\n  isRpcContext,\n  RpcContext,\n} from '../../context'\nimport { MarketTypeOf, MetadataStorage, StorageIdTypeOf, StorageTypeOf } from '../../meta'\nimport { MarketMetadata } from '../../meta/market'\nimport { Data, isIndexedData, isRpcData, NA, ZTG } from '../../primitives'\nimport { now } from '../time/functions/now'\nimport { ExchangeFullSetParams, PoolDeploymentParams, RpcPool } from '../types'\nimport { extractPoolCreationEventForMarket } from './functions/create'\nimport { ReportOutcomeParams } from './outcome'\n\nexport * from './functions/create/types'\nexport * from './functions/list/types'\n\n/**\n * Union type for Indexed and Rpc Markets.\n */\nexport type Market<\n  C extends Context<MS>,\n  MS extends MetadataStorage = MetadataStorage,\n> = Data<\n  C,\n  C extends RpcContext<MS> ? RpcMarket<C, MS> | SaturatedRpcMarket<C, MS> : never,\n  C extends FullContext<MS> | IndexerContext ? IndexedMarket<C, MS> : never,\n  MS\n>\n\n/**\n * Concrete Market type for a indexed market.\n */\nexport type IndexedMarket<\n  C extends Context<MS>,\n  MS extends MetadataStorage = MetadataStorage,\n> = FullMarketFragment & (C extends RpcContext<MS> ? MarketMethods : {})\n\n/**\n * Concrete Market type for a rpc market.\n */\nexport type RpcMarket<\n  C extends RpcContext<MS>,\n  MS extends MetadataStorage = MetadataStorage,\n> = ZeitgeistPrimitivesMarket &\n  MarketMethods & {\n    /**\n     * Market id/index. Set for conformity and convenince when fetching markets from rpc.\n     */\n    marketId: number\n    /**\n     * Fetch metadata from external storage(default IPFS).\n     */\n    fetchMetadata: Te.TaskEither<Error, MarketTypeOf<MS>, []>\n    /**\n     * Conform a rpc market to a indexed market type by fetching metadata, poolid from external storage(default IPFS) and decoding data.\n     */\n    saturate: Te.TaskEither<Error, SaturatedRpcMarket<C, MS>, []>\n    /**\n     * Fetch disputes for the market.\n     */\n    fetchDisputes: Te.TaskEither<Error, ZeitgeistPrimitivesMarketMarketDispute[], []>\n  }\n\nexport type SaturatedRpcMarket<\n  C extends RpcContext<MS>,\n  MS extends MetadataStorage,\n> = IndexedBase & MarketTypeOf<MS> & RpcMarket<C, MS>\n\n/**\n * The base type of indexed data that also can be infered from the rpc data.\n */\nexport type IndexedBase = Omit<FullMarketFragment, keyof MarketMetadata>\n\n/**\n * Interface on market with methods for deploying swap pools, buying and selling sets of assets..\n */\nexport type MarketMethods = {\n  /**\n   * Deploy a swap pool for the market.\n   *\n   * @param params Omit<PoolDeploymentParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, RpcPool>>\n   */\n  deploySwapPool: Te.TaskEither<\n    TransactionError,\n    RpcPool,\n    [params: Omit<PoolDeploymentParams, 'marketId'> & TransactionHooks]\n  >\n  /**\n   * Deploy a swap pool for the market and add liquidity.\n   *\n   * @param params Omit<PoolDeploymentParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, RpcPool>>\n   */\n  deploySwapPoolAndAdditionalLiquidity: Te.TaskEither<\n    TransactionError,\n    RpcPool,\n    [params: Omit<PoolDeploymentParams, 'marketId'> & TransactionHooks]\n  >\n  /**\n   * Buy a full set of market assets.\n   *\n   * @param params Omit<ExchangeFullSetParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  buyCompleteSet: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: Omit<ExchangeFullSetParams, 'marketId'> & TransactionHooks]\n  >\n  /**\n   * Sell a full set of market assets.\n   *\n   * @param params Omit<ExchangeFullSetParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  sellCompleteSet: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: Omit<ExchangeFullSetParams, 'marketId'> & TransactionHooks]\n  >\n  /**\n   * Redeem the shares for a market.\n   *\n   * @param params { signer: KeyringPairOrExtSigner } & TransactionHooks\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  redeemShares: Te.TaskEither<\n    Error,\n    ISubmittableResult,\n    [params: { signer: KeyringPairOrExtSigner } & TransactionHooks]\n  >\n  /**\n   * Dispute the current market outcome with a proposed new outcome.\n   *\n   * @param params Omit<ReportOutcomeParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  disputeOutcome: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: Omit<ReportOutcomeParams, 'marketId'> & TransactionHooks]\n  >\n  /**\n   * Report the outcome of a market. Can only be called by the markets oracle address.\n   *\n   * @param params Omit<ReportOutcomeParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  reportOutcome: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: Omit<ReportOutcomeParams, 'marketId'> & TransactionHooks]\n  >\n  /**\n   * Destroy a market, including its outcome assets, market account and pool account.\n   *\n   * Must be called by `DestroyOrigin`. Bonds (unless already returned) are slashed without\n   * exception. Can currently only be used for destroying CPMM markets.\n   *\n   * @origin DestroyOrigin\n   * @param params {signer: KeyringPairOrExtSigner}\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  adminDestroyMarket: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: { signer: KeyringPairOrExtSigner } & TransactionHooks]\n  >\n  /**\n   * Immediately move an open market to closed.\n   *\n   * @origin CloseOrigin\n   * @param signer {signer: KeyringPairOrExtSigner}\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  adminMoveMarketToClosed: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: { signer: KeyringPairOrExtSigner } & TransactionHooks]\n  >\n  /**\n   * Immediately move a reported or disputed market to resolved.\n   *\n   * @origin ResolveOrigin\n   * @param signer {signer: KeyringPairOrExtSigner}\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  adminMoveMarketToResolved: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: { signer: KeyringPairOrExtSigner } & TransactionHooks]\n  >\n  /**\n   * Approves a market that is waiting for approval from the\n   * advisory committee.\n   *\n   * @origin ApproveOrigin\n   * @param signer {signer: KeyringPairOrExtSigner}\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  approveMarket: Te.TaskEither<\n    Error,\n    ISubmittableResult,\n    [params: { signer: KeyringPairOrExtSigner } & TransactionHooks]\n  >\n  /**\n   * Clean up the pool of a resolved market.\n   *\n   * @origin The root origin.\n   * @param params Omit<ReportOutcomeParams, 'marketId'>\n   * @returns Promise<EitherInterface<Error, ISubmittableResult>>\n   */\n  adminCleanUpPool: Te.TaskEither<\n    TransactionError,\n    ISubmittableResult,\n    [params: Omit<ReportOutcomeParams, 'marketId'> & TransactionHooks]\n  >\n}\n\n/**\n * Union type of all market statuses as string.\n */\nexport type MarketStatus = ZeitgeistPrimitivesMarketMarketStatus['type'] | 'Destroyed'\n\n/**\n * Type for market deadlines as numbers.\n */\nexport type MarketDeadlines = {\n  gracePeriod: number\n  oracleDuration: number\n  disputeDuration: number\n}\n\n/**\n * Typeguard to check if market has associated marketmethods.\n *\n * @param market Market<C, MS>\n * @returns market is Market<C, MS> & MarketMethods\n */\nexport const hasMarketMethods = <\n  C extends Context<MS>,\n  MS extends MetadataStorage = MetadataStorage,\n>(\n  market: Market<C, MS>,\n): market is Market<C, MS> & MarketMethods => 'deploySwapPool' in market\n\n/**\n * Augment a market primitive with id and data expanding utility functions.\n *\n * @param context RpcContext\n * @param id u128\n * @param primitive ZeitgeistPrimitivesMarket\n * @returns AugmentedAugmentedRpcMarket\n */\nexport const rpcMarket = <C extends RpcContext<MS>, MS extends MetadataStorage>(\n  context: C,\n  id: u128 | number,\n  primitive: ZeitgeistPrimitivesMarket,\n): Market<C, MS> => {\n  let market = primitive as Market<C, MS>\n\n  market.marketId = isNumber(id) ? id : id.toNumber()\n\n  market.fetchMetadata = Te.from(async () => {\n    const hex = market.metadata.toHex()\n    const cid = new CID('f0155' + hex.slice(2))\n    const id = { __meta: 'markets', cid: cid } as StorageIdTypeOf<MS['markets']>\n    const metadata = await context.storage.of('markets').get(id)\n    return metadata.unwrapOr(\n      throwsC(Error(`could not fetch metadata for market: ${market.marketId}`)),\n    )\n  })\n\n  market.fetchDisputes = Te.from(async () => {\n    const disputes = await context.api.query.predictionMarkets.disputes(id)\n    return disputes.toArray()\n  })\n\n  market.saturate = Te.from(async () => {\n    const [metadata, pool] = await Promise.all([\n      market.fetchMetadata(),\n      context.api.query.marketCommons.marketPool(market.marketId).then(id => {\n        if (id.isSome) {\n          return context.api.query.swaps.pools(id.unwrap()).then(p => p.unwrapOr(null))\n        }\n      }),\n    ])\n\n    const outcomeAssets = pool ? pool.assets.toArray().map(a => JSON.stringify(a)) : []\n\n    const base: IndexedBase = {\n      id: `${market.marketId}`,\n      marketId: market.marketId,\n      creation: primitive.creation.type,\n      creator: primitive.creator.toHuman(),\n      oracle: primitive.oracle.toHuman(),\n      deadlines: primitive.deadlines,\n      creatorFee: primitive.creatorFee.toNumber(),\n      scoringRule: primitive.scoringRule.type,\n      outcomeAssets: outcomeAssets,\n      status: primitive.status.toString() as FullMarketFragment['status'],\n      period: primitive.period.toHuman() as FullMarketFragment['period'],\n      marketType: primitive.marketType.toHuman() as FullMarketFragment['marketType'],\n      disputeMechanism:\n        primitive.disputeMechanism.toHuman() as FullMarketFragment['disputeMechanism'],\n      report: primitive.report.toHuman() as FullMarketFragment['report'],\n      resolvedOutcome:\n        primitive.resolvedOutcome.toHuman() as FullMarketFragment['resolvedOutcome'],\n    }\n\n    let saturatedRpcMarket = {\n      ...base,\n      ...(metadata as StorageTypeOf<MS['markets']>),\n    } as SaturatedRpcMarket<C, MS>\n\n    attachMarketMethods<C, MS>(context, saturatedRpcMarket as Market<C, MS>)\n\n    return saturatedRpcMarket\n  })\n\n  market = attachMarketMethods(context, market)\n\n  return market\n}\n\n/**\n * Attach transaction interfaces for deploying pool etc to market.\n *\n * @param context Context<MS>\n * @param market Market<C, MS>\n * @returns Market<C, MS>\n */\nexport const attachMarketMethods = <C extends Context<MS>, MS extends MetadataStorage>(\n  context: C,\n  market: Market<C, MS>,\n): Market<C, MS> => {\n  if (isRpcContext<MS>(context)) {\n    let marketWithMethods = market as Market<typeof context, MS>\n\n    marketWithMethods.deploySwapPool = Te.from(async params => {\n      assert(!(await hasPool(context, market)), () => {\n        throw new Error('Cannot deploy pool for market that allready has pool.')\n      })\n\n      const tx = context.api.tx.predictionMarkets.deploySwapPoolForMarket(\n        market.marketId,\n        params.swapFee,\n        params.amount,\n        params.weights,\n      )\n\n      const extrinsic = await signAndSend({\n        api: context.api,\n        tx,\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n\n      const pool = extractPoolCreationEventForMarket(\n        context,\n        extrinsic.events,\n        market.marketId,\n      )\n\n      return pool.unwrap()\n    })\n\n    marketWithMethods.deploySwapPoolAndAdditionalLiquidity = Te.from(async params => {\n      assert(!(await hasPool(context, market)), () => {\n        throw new Error('Cannot deploy pool for market that allready has pool.')\n      })\n\n      const tx = context.api.tx.predictionMarkets.deploySwapPoolAndAdditionalLiquidity(\n        market.marketId,\n        params.swapFee,\n        params.amount,\n        params.weights,\n      )\n\n      const extrinsic = await signAndSend({\n        api: context.api,\n        tx,\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n\n      const pool = extractPoolCreationEventForMarket(\n        context,\n        extrinsic.events,\n        market.marketId,\n      )\n\n      return pool.unwrap()\n    })\n\n    marketWithMethods.buyCompleteSet = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.buyCompleteSet(market.marketId, params.amount),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.sellCompleteSet = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.sellCompleteSet(\n          market.marketId,\n          params.amount,\n        ),\n        signer: params.signer,\n      })\n    })\n\n    marketWithMethods.redeemShares = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.redeemShares(market.marketId),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.disputeOutcome = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.dispute(market.marketId, params.outcome),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.reportOutcome = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.report(market.marketId, params.outcome),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.adminDestroyMarket = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.adminDestroyMarket(market.marketId),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.adminMoveMarketToClosed = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.adminMoveMarketToClosed(market.marketId),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.adminMoveMarketToResolved = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.adminMoveMarketToResolved(market.marketId),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.approveMarket = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.predictionMarkets.approveMarket(market.marketId),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    marketWithMethods.adminCleanUpPool = Te.from(async params => {\n      return await signAndSend({\n        api: context.api,\n        tx: context.api.tx.swaps.adminCleanUpPool(market.marketId, params.outcome),\n        signer: params.signer,\n        hooks: params.hooks,\n      })\n    })\n\n    return marketWithMethods\n  }\n  return market\n}\n\n/**\n * Get the pool id of a market in a way to works for both indexed and rpc data.\n *\n * @param market Market<C, MS>\n * @returns Promise<O.IOption<number>>\n */\nexport const getPoolId = async <\n  C extends Context<MS>,\n  MS extends MetadataStorage = MetadataStorage,\n>(\n  context: C,\n  market: Market<C, MS>,\n): Promise<O.IOption<number>> => {\n  if (isIndexedData(market)) {\n    return market.pool?.poolId ? O.option(O.some(market.pool?.poolId)) : O.option(O.none())\n  } else {\n    if (isRpcContext(context)) {\n      const pool = await context.api.query.marketCommons.marketPool(market.marketId)\n      return pool.isSome ? O.option(O.some(pool.unwrap().toNumber())) : O.option(O.none())\n    } else {\n      const {\n        pools: [pool],\n      } = await context.indexer.pools({\n        where: {\n          marketId_eq: market.marketId,\n        },\n      })\n      return pool ? O.option(O.some(pool.poolId)) : O.option(O.none())\n    }\n  }\n}\n\n/**\n * Check if a rpc or indexed market has pool associated.\n *\n * @param market Market<C, MS>\n * @returns Promise<boolean>\n */\nexport const hasPool = async <\n  C extends Context<MS>,\n  MS extends MetadataStorage = MetadataStorage,\n>(\n  context: C,\n  market: Market<C, MS>,\n): Promise<boolean> => {\n  return O.isSome(await getPoolId(context, market))\n}\n\n/**\n * Get the market status.\n *\n * @param market Market<Context>\n * @returns MarketStatus\n */\nexport const getStatus = (market: Market<Context>): MarketStatus => {\n  return isRpcData(market)\n    ? market.status.type\n    : (market.status as ZeitgeistPrimitivesMarketMarketStatus['type'])\n}\n\n/**\n * Get the market deadlines.\n *\n * @param market Market<Context>\n * @returns MarketDeadlines\n */\nexport const getDeadlines = (market: Market<Context>): MarketDeadlines => {\n  if (isRpcData(market)) {\n    return {\n      gracePeriod: market.deadlines.gracePeriod.toNumber() as number,\n      oracleDuration: market.deadlines.oracleDuration.toNumber() as number,\n      disputeDuration: market.deadlines.disputeDuration.toNumber() as number,\n    }\n  }\n  return {\n    gracePeriod: Number(market.deadlines?.gracePeriod ?? 0),\n    oracleDuration: Number(market.deadlines?.oracleDuration ?? 0),\n    disputeDuration: Number(market.deadlines?.disputeDuration ?? 0),\n  }\n}\n\n/**\n * Get the market period as a Timespan.\n *\n * @param market Market<Context>\n * @param now ChainTime\n * @returns Timespan\n */\nexport const timespanOf = (market: Market<Context>, now: ChainTime): Timespan => {\n  if (isRpcData(market)) {\n    const start = market.period.isTimestamp\n      ? market.period.asTimestamp.start.toNumber()\n      : blockDate(now, market.period.asBlock.start.toNumber())\n    const end = market.period.isTimestamp\n      ? market.period.asTimestamp.end.toNumber()\n      : blockDate(now, market.period.asBlock.end.toNumber())\n\n    return { start, end } as Timespan\n  }\n\n  return {\n    start: new Date(market.period.start),\n    end: new Date(market.period.end),\n  }\n}\n\n/**\n * Check if a market has a report.\n *\n * @param market Market<Context>\n * @returns boolean\n */\nexport const hasReport = (market: Market<Context>): boolean => {\n  return isRpcData(market) ? market.report.isSome : !!market.report\n}\n\n/**\n * Get the market reporter address if market is reported.\n *\n * @param market Market<Context>\n * @returns O.IOption<string>\n */\nexport const getReporter = (market: Market<Context>) => {\n  return O.fromNullable(\n    isRpcData(market) ? market.report.unwrapOr(null)?.by.toString() : market.report?.by,\n  )\n}\n\n/**\n * Get the market reported at block if market is reported.\n *\n * @param market Market<Context>\n * @returns O.IOption<number>\n */\nexport const getReportedAt = (market: Market<Context>) => {\n  return O.fromNullable(\n    isRpcData(market) ? market.report.unwrapOr(null)?.at.toNumber() : market.report?.at,\n  )\n}\n\n/**\n * Get the projected end timestamp for a market.\n *\n * @note If market has period as timestamps will use that directly and if its set to a block end date\n * it will project a approximate end timestamp based on the on chain current block and block time.\n *\n * @param context Context<MS>\n * @param market Market<C, MS>\n * @returns Promise<number | NA>\n */\nexport const projectEndTimestamp = async <\n  C extends Context<MS>,\n  MS extends MetadataStorage,\n>(\n  ctx: C,\n  market: Market<C, MS>,\n  _now?: ChainTime,\n): Promise<number | NA> => {\n  const chainTime = isRpcContext(ctx) ? await (_now ?? now(ctx)) : null\n\n  if (isRpcData(market)) {\n    if (market.period.isTimestamp) {\n      return market.period.asTimestamp.end.toNumber()\n    } else if (chainTime) {\n      const endBlock = Number(market.period.asBlock[1].toHuman())\n      return blockDate(chainTime, endBlock).getTime()\n    }\n  } else {\n    if (market.period.timestamp) {\n      return Number(market.period.timestamp[1])\n    } else if (chainTime) {\n      const endBlock = (market.period.block as Array<number>)[1]\n      return blockDate(chainTime, endBlock).getTime()\n    }\n  }\n\n  return NA\n}\n\n/**\n * Get scalar market bounds.\n *\n * @param market Market<Context>\n * @returns E.IEither<Error, [Decimal, Decimal]>\n */\nexport const getScalarBounds = (\n  market: Market<Context>,\n): E.IEither<Error, [Decimal, Decimal]> => {\n  if (isRpcData(market)) {\n    if (!market.marketType.isScalar)\n      return E.either(E.left(new Error('Not a scalar market')))\n    const bounds = market.marketType.asScalar\n    return E.either(\n      E.right([\n        new Decimal(bounds[0].toString()).div(ZTG),\n        new Decimal(bounds[1].toString()).div(ZTG),\n      ]),\n    )\n  } else {\n    if (!market.marketType.scalar) return E.either(E.left(new Error('Not a scalar market')))\n    const bounds = market.marketType.scalar as [string, string]\n    return E.either(\n      E.right([new Decimal(bounds[0]).div(ZTG), new Decimal(bounds[1]).div(ZTG)]),\n    )\n  }\n}\n\n/**\n *\n *\n * @param ctx Context<MS>\n * @param market Market<C>\n */\nexport const getPrediction = async <C extends Context<MS>, MS extends MetadataStorage>(\n  ctx: C,\n  market: Market<Context>,\n) => {\n  if (isRpcData(market)) {\n    if (market.status.type === 'Resolved') {\n      const report = market.report.unwrap()\n      const outcome = report.outcome.toNumber()\n      const pool = (await getPool(ctx, market)).unwrap()!!\n      poolPrices\n    }\n  } else {\n  }\n}\n"],"names":[],"mappings":"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"}
'use strict';

var infinity = require('@zeitgeistpm/utility/dist/infinity');
var O = require('@zeitgeistpm/utility/dist/option');
var Time = require('@zeitgeistpm/utility/dist/time');
var index = require('../../../time/functions/now/index.js');
var market = require('../../market.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var O__namespace = /*#__PURE__*/_interopNamespaceDefault(O);
var Time__namespace = /*#__PURE__*/_interopNamespaceDefault(Time);

/**
 * Get the market stage for a market.
 * The market stage contains information about the current stage of the market lifecycle
 * and the total time of current the stage + estimated time remaining for the current stage.
 *
 * @param ctx Context
 * @param market Market<Context>
 * @param time ChainTime | undefined
 * @returns Promise<MarketStage>
 */
const getStage = async (ctx, market$1, providedTime) => {
    const time = providedTime ?? (await index.now(ctx));
    const status = market.getStatus(market$1);
    const deadlines = market.getDeadlines(market$1);
    const { start, end } = Time__namespace.asBlocks(time, market.timespanOf(market$1, time));
    if (status === 'Proposed') {
        return { type: 'Proposed', remainingTime: infinity.infinity, totalTime: infinity.infinity };
    }
    if (status === 'Active') {
        return { type: 'Trading', remainingTime: end - time.now, totalTime: end - start };
    }
    if (status === 'Closed') {
        const graceDuration = Time__namespace.toMs(time, { start: 0, end: deadlines.gracePeriod });
        const oracleDuration = Time__namespace.toMs(time, { start: 0, end: deadlines.oracleDuration });
        const oraclePeriodStarts = end + graceDuration;
        const oracleReportingEnds = oraclePeriodStarts + oracleDuration;
        //TODO: if market period is in blocks, use blocks to determine actual stage, time remainng and total time can still be calculated.
        if (time.now < oraclePeriodStarts) {
            return {
                type: 'GracePeriod',
                totalTime: graceDuration,
                remainingTime: oraclePeriodStarts - time.now,
            };
        }
        if (time.now < oracleReportingEnds) {
            return {
                type: 'OracleReportingPeriod',
                remainingTime: oracleDuration - (time.now - oraclePeriodStarts),
                totalTime: oracleDuration,
            };
        }
        else {
            return {
                type: 'OpenReportingPeriod',
                remainingTime: infinity.infinity,
                totalTime: infinity.infinity,
            };
        }
    }
    if (status === 'Reported') {
        const disputeDuration = Time__namespace.toMs(time, { start: 0, end: deadlines.disputeDuration });
        const reportedAtBlock = market.getReportedAt(market$1).unwrapOr(0);
        const reportedAtTimestamp = Time__namespace.blockDate(time, reportedAtBlock).getTime();
        const remainingTime = disputeDuration - (time.now - reportedAtTimestamp);
        return { type: 'Reported', remainingTime, totalTime: disputeDuration };
    }
    if (status === 'Disputed') {
        const report = await ctx.api.query.authorized.authorizedOutcomeReports(market$1.marketId);
        if (!report.isEmpty) {
            const block = await ctx.api.rpc.chain.getBlock(report.createdAtHash);
            const reportedAtBlock = block.block.header.number.toNumber();
            const reportedAtTimestamp = Time__namespace.blockDate(time, reportedAtBlock).getTime();
            const correctionPeriod = O__namespace.tryCatch(() => ctx.api.consts.authorized['correctionPeriod'].toNumber()).unwrapOr(7200);
            const correctionDuration = Time__namespace.toMs(time, { start: 0, end: correctionPeriod });
            const remainingTime = correctionDuration - (time.now - reportedAtTimestamp);
            return { type: 'AuthorizedReport', remainingTime, totalTime: correctionDuration };
        }
        return { type: 'Disputed', remainingTime: infinity.infinity, totalTime: infinity.infinity };
    }
    if (status === 'Resolved') {
        return { type: 'Resolved', remainingTime: infinity.infinity, totalTime: infinity.infinity };
    }
    if (status === 'Destroyed') {
        return { type: 'Destroyed', remainingTime: infinity.infinity, totalTime: infinity.infinity };
    }
    throw new Error(`Couldn't determine market stage by status ${status}`);
};

exports.getStage = getStage;
//# sourceMappingURL=index.js.map

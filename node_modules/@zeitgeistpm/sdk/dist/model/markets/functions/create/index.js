'use strict';

var rpc = require('@zeitgeistpm/rpc');
var E = require('@zeitgeistpm/utility/dist/either');
var Te = require('@zeitgeistpm/utility/dist/taskeither');
var pool = require('../../../swaps/pool.js');
var market = require('../../market.js');
var types = require('./types.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var E__namespace = /*#__PURE__*/_interopNamespaceDefault(E);
var Te__namespace = /*#__PURE__*/_interopNamespaceDefault(Te);

/**
 * Create a market on chain.
 *
 * @generic C extends RpcContext<MS> | FullContext<MS>
 * @generic MS extends MetadataStorage
 * @param context C
 * @param params CreateMarketParams<C, MS>
 * @returns void
 */
const create = async (context, params) => {
    const { tx, rollbackMetadata } = await transaction(context, params);
    const response = rpc.signAndSend({
        api: context.api,
        tx,
        signer: params.signer,
        hooks: params.hooks,
    });
    const submittableResult = await response.unrightOr(error => {
        rollbackMetadata();
        throw error;
    });
    const saturate = extraction(context, submittableResult, params);
    return {
        raw: submittableResult,
        saturate,
    };
};
/**
 * Create lazy transaction for creating a market.
 *
 * @generic C extends RpcContext<MS> | FullContext<MS>
 * @generic MS extends MetadataStorage
 * @param context C
 * @param params CreateMarketParams<C, MS>
 * @returns CreateMarketTransaction
 */
const transaction = async (context, params) => {
    let tx;
    const storage = context.storage.of('markets');
    const cid = await storage.put(params.metadata);
    const rollbackMetadata = Te__namespace.from(async () => {
        if (!context.storage)
            return;
        await context.storage.of('markets').del(cid);
    });
    if (types.isWithPool(params)) {
        tx = context.api.tx.predictionMarkets.createCpmmMarketAndDeployAssets(params.baseAsset, params.oracle, params.period, params.deadlines, { Sha3_384: cid.cid.multihash.bytes }, params.marketType, params.disputeMechanism, params.pool.swapFee, params.pool.amount, params.pool.weights);
    }
    else {
        tx = context.api.tx.predictionMarkets.createMarket(params.baseAsset, params.oracle, params.period, params.deadlines, { Sha3_384: cid.cid.multihash.bytes }, params.creationType, params.marketType, params.disputeMechanism, params.scoringRule === 'Cpmm' ? 'CPMM' : params.scoringRule ?? 'CPMM');
    }
    return {
        tx,
        rollbackMetadata,
    };
};
/**
 * Lazily extract metadata from the market creation block.
 *
 * @generic MS extends MetadataStorage
 * @generic P extends CreateMarketParams<MS
 * @param context RpcContext<MS>
 * @param result ISubmittableResult
 * @param params P
 * @returns () => EitherInterface<Error, CreateMarketData<P>>
 */
const extraction = (context, result, params) => () => E__namespace.tryCatch(() => {
    const market = extractMarketCreationEventForAddress(context, result.events, params.signer.address).unwrap();
    const pool = types.isWithPool(params)
        ? extractPoolCreationEventForMarket(context, result.events, market.marketId).unwrap()
        : undefined;
    return {
        market,
        pool,
    };
});
/**
 * Get the market creation event from the finalized block events.
 *
 * @private
 *
 * @param api ApiPromise
 * @param events EventRecord[]
 * @param address AddressOrPair
 */
const extractMarketCreationEventForAddress = (ctx, events, address) => E__namespace.tryCatch(() => {
    for (const { event } of events) {
        if (ctx.api.events.predictionMarkets.MarketCreated.is(event)) {
            const [id, , primitive] = event.data;
            if (primitive.creator.eq(address)) {
                return market.rpcMarket(ctx, id, primitive);
            }
        }
    }
    throw new Error('No market creation event found on finalized block. Should not happen.');
});
/**
 * Get the pool creation event from the finalized block events.
 *
 * @private
 *
 * @param api ApiPromise
 * @param events EventRecord[]
 * @param marketId number
 */
const extractPoolCreationEventForMarket = (ctx, events, marketId) => E__namespace.tryCatch(() => {
    for (const { event } of events) {
        if (ctx.api.events.swaps.PoolCreate.is(event)) {
            const [{ poolId }, pool$1] = event.data;
            if (pool$1.marketId.eq(marketId)) {
                return pool.rpcPool(ctx, poolId.toNumber(), pool$1);
            }
        }
    }
    throw new Error('No pool creation event found on finalized block. Should not happen when creating with pool.');
});

exports.create = create;
exports.extractMarketCreationEventForAddress = extractMarketCreationEventForAddress;
exports.extractPoolCreationEventForMarket = extractPoolCreationEventForMarket;
exports.transaction = transaction;
//# sourceMappingURL=index.js.map

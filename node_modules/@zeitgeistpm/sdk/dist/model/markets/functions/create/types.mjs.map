{"version":3,"file":"types.mjs","sources":["../../../../../src/model/markets/functions/create/types.ts"],"sourcesContent":["import type { SubmittableExtrinsic } from '@polkadot/api/types'\nimport type {\n  ZeitgeistPrimitivesAsset,\n  ZeitgeistPrimitivesMarketMarketCreation,\n  ZeitgeistPrimitivesMarketMarketDisputeMechanism,\n  ZeitgeistPrimitivesPoolScoringRule,\n} from '@polkadot/types/lookup'\nimport type { ISubmittableResult } from '@polkadot/types/types'\nimport type { KeyringPairOrExtSigner, TransactionHooks } from '@zeitgeistpm/rpc'\nimport type { IEither } from '@zeitgeistpm/utility/dist/either'\nimport * as Te from '@zeitgeistpm/utility/dist/taskeither'\nimport { AssetId } from '../../../../primitives'\nimport { RpcContext } from '../../../../context'\nimport { MarketTypeOf, MetadataStorage } from '../../../../meta'\nimport { Pool } from '../../../swaps/pool'\nimport { Market } from '../../market'\n\n/**\n * Union type for creating a standalone market or permissionless cpmm market with pool.\n */\nexport type CreateMarketParams<C extends RpcContext<MS>, MS extends MetadataStorage> = (\n  | CreateStandaloneMarketParams<C, MS>\n  | CreateMarketWithPoolParams<C, MS>\n) &\n  TransactionHooks\n\n/**\n * Base parameters for creating a market.\n */\nexport type CreateMarketBaseParams<C extends RpcContext<MS>, MS extends MetadataStorage> = {\n  /**\n   * The base asset of the market. Can be ZTG or another\n   */\n  baseAsset: ZeitgeistPrimitivesAsset | AssetId\n  /**\n   * The signer of the transaction. Can be a unlocked keyring pair or extension.\n   */\n  signer: KeyringPairOrExtSigner\n  /**\n   * Metadata to store in external storage alongside the market.\n   */\n  metadata: MarketTypeOf<MS>\n  /**\n   * Type of market, categorical or scalar\n   */\n  marketType:\n    | {\n        Categorical: number\n      }\n    | {\n        Scalar: [number, number]\n      }\n  /**\n   * The resolver of the market outcome\n   */\n  oracle: string\n  /**\n   * The period of the market in tuple of timestamps or block numbers.\n   */\n  period:\n    | {\n        Block: [number, number]\n      }\n    | {\n        Timestamp: [number, number]\n      }\n\n  deadlines: {\n    gracePeriod: number\n    oracleDuration: number\n    disputeDuration: number\n  }\n  /**\n   * Market dispute mechanism.\n   * @note Authorized is the only one available atm.\n   */\n  disputeMechanism:\n    | ZeitgeistPrimitivesMarketMarketDisputeMechanism\n    | 'Authorized'\n    | 'Court'\n    | 'SimpleDisputes'\n}\n\n/**\n * Parameters for creating a market without a pool\n */\nexport type CreateStandaloneMarketParams<\n  C extends RpcContext<MS>,\n  MS extends MetadataStorage = C['storage'],\n> = CreateMarketBaseParams<C, MS> & {\n  /**\n   * Market scoring rule.\n   *\n   * @default Cpmm\n   * @note Cpmm is the only one available atm. Rikkido will become available in a future update.\n   */\n  scoringRule?: ZeitgeistPrimitivesPoolScoringRule['type']\n  /**\n   * Market creation type, permissionless or advised.\n   */\n  creationType: ZeitgeistPrimitivesMarketMarketCreation['type']\n}\n\n/**\n * Parameters for creating a market with a pool.\n */\nexport type CreateMarketWithPoolParams<\n  C extends RpcContext<MS>,\n  MS extends MetadataStorage = C['storage'],\n> = CreateMarketBaseParams<C, MS> & {\n  pool: {\n    /**\n     * The fee to swap in and out of the pool.\n     */\n    swapFee: string\n    /**\n     * The ammount to deploy in ZTG\n     */\n    amount: string\n    /**\n     * Weighting of the assets.\n     */\n    weights: string[]\n  }\n}\n\n/**\n * Check if params is with pool\n *\n * @param params CreateMarketParams\n * @returns params is CreateMarketWithPoolParams\n */\nexport const isWithPool = <C extends RpcContext<MS>, MS extends MetadataStorage>(\n  params: CreateMarketParams<C, MS>,\n): params is CreateMarketWithPoolParams<C, MS> => {\n  return 'pool' in params\n}\n\n/**\n * The result of creating a market.\n * Market and pool(if created) can be lazily extracted from events using the data function.\n *\n * @generic P extends CreateMarketParams - Data will contain market and pool if params is with pool\n */\nexport type CreateMarketResult<C extends RpcContext<MS>, MS extends MetadataStorage> = {\n  raw: ISubmittableResult\n  /**\n   * Lazy function to saturate response with created Market and Pool.\n   *\n   * @example ```ts\n   * const result = await sdk.model.markets.create(...params)\n   * const { market, pool } = result.saturate().unwrap()\n   * ```\n   *\n   * @returns EitherInterface<Error, CreateMarketData<P>>\n   */\n  saturate: () => IEither<Error, CreateMarketData<C, MS, CreateMarketParams<C, MS>>>\n}\n\n/**\n * The lazy data extracted from the market creation result.\n *\n * @generic P extends CreateMarketParams - Data will contain market and pool if params is with pool\n */\nexport type CreateMarketData<\n  C extends RpcContext<MS>,\n  MS extends MetadataStorage,\n  P extends CreateMarketParams<C, MS>,\n> = {\n  /**\n   * The market created by the extrinsic.\n   */\n  market: Market<C, MS>\n  pool: P extends CreateMarketWithPoolParams<C, MS> ? Pool<C, MS> : undefined\n}\n\n/**\n * A transaction object encapsulating the raw transaction and a rollback function\n * to remove metadata from storage if submission fails.\n *\n * @note its the consumers responsibility to call rollback if transaction fails.\n */\nexport type CreateMarketTransaction = {\n  tx: SubmittableExtrinsic<'promise', ISubmittableResult>\n  rollbackMetadata: Te.TaskEither<Error, void, []> //() => Promise<IEither<Error, void>>\n}\n"],"names":[],"mappings":"AA8HA;;;;;AAKG;AACU,MAAA,UAAU,GAAG,CACxB,MAAiC,KACc;IAC/C,OAAO,MAAM,IAAI,MAAM,CAAA;AACzB;;;;"}
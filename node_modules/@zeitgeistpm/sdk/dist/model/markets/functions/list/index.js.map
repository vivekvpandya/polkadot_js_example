{"version":3,"file":"index.js","sources":["../../../../../src/model/markets/functions/list/index.ts"],"sourcesContent":["import {\n  Context,\n  IndexerContext,\n  isFullContext,\n  isIndexerContext,\n  isRpcContext,\n  RpcContext,\n} from '../../../../context'\nimport { MetadataStorage } from '../../../../meta'\nimport { isPaginated } from '../../../../primitives/pagination'\nimport {\n  MarketList,\n  MarketsListQuery,\n  rpcMarket,\n  attachMarketMethods,\n  IndexedMarket,\n  Market,\n} from '../../types'\n\n/**\n * Query for a list of markets.\n * Query capabilities and returned data differentiates between a rpc and indexer context.\n *\n * @generic C - Context\n * @param context C - the context to query inb\n * @param query ListQuery<C>\n * @returns Promise<MarketList<C>>\n */\nexport const list = async <C extends Context<MS>, MS extends MetadataStorage>(\n  context: C,\n  query?: MarketsListQuery<C>,\n): Promise<MarketList<C, MS>> => {\n  if (isFullContext<MS>(context) || isIndexerContext<MS>(context)) {\n    return listFromIndexer<typeof context, MS>(context, query)\n  } else if (isRpcContext<MS>(context)) {\n    return listFromRpc<typeof context, MS>(context, query)\n  }\n  return []\n}\n\n/**\n * Concrete listing function for indexer context\n * @private\n */\nconst listFromIndexer = async <C extends IndexerContext, MS extends MetadataStorage>(\n  context: C,\n  query?: MarketsListQuery<C>,\n): Promise<MarketList<C, MS>> => {\n  return (await context.indexer.markets(query)).markets.map(market =>\n    attachMarketMethods<C, MS>(context, market as Market<C, MS>),\n  ) as MarketList<C, MS>\n}\n\n/**\n * Concrete listing function for rpc context\n * @private\n */\nconst listFromRpc = async <C extends RpcContext<MS>, MS extends MetadataStorage>(\n  context: C,\n  query?: MarketsListQuery<C>,\n): Promise<MarketList<C, MS>> => {\n  const entries =\n    query && isPaginated(query)\n      ? await context.api.query.marketCommons.markets.entriesPaged({\n          args: [],\n          pageSize: query.limit,\n          startKey: `${query.offset}`,\n        })\n      : await context.api.query.marketCommons.markets.entries()\n\n  const list = entries.map(\n    ([\n      {\n        args: [marketId],\n      },\n      market,\n    ]) => rpcMarket<C, MS>(context, marketId, market.unwrap()),\n  )\n\n  return list as MarketList<C, MS>\n}\n"],"names":["isFullContext","isIndexerContext","isRpcContext","market","attachMarketMethods","isPaginated","rpcMarket"],"mappings":";;;;;;;AAmBA;;;;;;;;AAQG;AACU,MAAA,IAAI,GAAG,OAClB,OAAU,EACV,KAA2B,KACG;IAC9B,IAAIA,mBAAa,CAAK,OAAO,CAAC,IAAIC,sBAAgB,CAAK,OAAO,CAAC,EAAE;AAC/D,QAAA,OAAO,eAAe,CAAqB,OAAO,EAAE,KAAK,CAAC,CAAA;AAC3D,KAAA;AAAM,SAAA,IAAIC,kBAAY,CAAK,OAAO,CAAC,EAAE;AACpC,QAAA,OAAO,WAAW,CAAqB,OAAO,EAAE,KAAK,CAAC,CAAA;AACvD,KAAA;AACD,IAAA,OAAO,EAAE,CAAA;AACX,EAAC;AAED;;;AAGG;AACH,MAAM,eAAe,GAAG,OACtB,OAAU,EACV,KAA2B,KACG;IAC9B,OAAO,CAAC,MAAM,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,GAAG,CAACC,QAAM,IAC9DC,0BAAmB,CAAQ,OAAO,EAAED,QAAuB,CAAC,CACxC,CAAA;AACxB,CAAC,CAAA;AAED;;;AAGG;AACH,MAAM,WAAW,GAAG,OAClB,OAAU,EACV,KAA2B,KACG;AAC9B,IAAA,MAAM,OAAO,GACX,KAAK,IAAIE,sBAAW,CAAC,KAAK,CAAC;AACzB,UAAE,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,aAAa,CAAC,OAAO,CAAC,YAAY,CAAC;AACzD,YAAA,IAAI,EAAE,EAAE;YACR,QAAQ,EAAE,KAAK,CAAC,KAAK;AACrB,YAAA,QAAQ,EAAE,CAAA,EAAG,KAAK,CAAC,MAAM,CAAE,CAAA;SAC5B,CAAC;AACJ,UAAE,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,aAAa,CAAC,OAAO,CAAC,OAAO,EAAE,CAAA;AAE7D,IAAA,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CACtB,CAAC,CACC,EACE,IAAI,EAAE,CAAC,QAAQ,CAAC,GACjB,EACDF,QAAM,EACP,KAAKG,gBAAS,CAAQ,OAAO,EAAE,QAAQ,EAAEH,QAAM,CAAC,MAAM,EAAE,CAAC,CAC3D,CAAA;AAED,IAAA,OAAO,IAAyB,CAAA;AAClC,CAAC;;;;"}
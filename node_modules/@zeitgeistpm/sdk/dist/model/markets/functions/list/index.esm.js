import { isFullContext, isIndexerContext, isRpcContext } from '../../../../context/types.esm.js';
import { isPaginated } from '../../../../primitives/pagination.esm.js';
import { attachMarketMethods, rpcMarket } from '../../market.esm.js';
import '@zeitgeistpm/utility/dist/infinity';

/**
 * Query for a list of markets.
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query inb
 * @param query ListQuery<C>
 * @returns Promise<MarketList<C>>
 */
const list = async (context, query) => {
    if (isFullContext(context) || isIndexerContext(context)) {
        return listFromIndexer(context, query);
    }
    else if (isRpcContext(context)) {
        return listFromRpc(context, query);
    }
    return [];
};
/**
 * Concrete listing function for indexer context
 * @private
 */
const listFromIndexer = async (context, query) => {
    return (await context.indexer.markets(query)).markets.map(market => attachMarketMethods(context, market));
};
/**
 * Concrete listing function for rpc context
 * @private
 */
const listFromRpc = async (context, query) => {
    const entries = query && isPaginated(query)
        ? await context.api.query.marketCommons.markets.entriesPaged({
            args: [],
            pageSize: query.limit,
            startKey: `${query.offset}`,
        })
        : await context.api.query.marketCommons.markets.entries();
    const list = entries.map(([{ args: [marketId], }, market,]) => rpcMarket(context, marketId, market.unwrap()));
    return list;
};

export { list };
//# sourceMappingURL=index.esm.js.map

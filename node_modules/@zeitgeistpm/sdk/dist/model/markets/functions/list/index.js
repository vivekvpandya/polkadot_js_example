'use strict';

var types = require('../../../../context/types.js');
var pagination = require('../../../../primitives/pagination.js');
var market = require('../../market.js');
require('@zeitgeistpm/utility/dist/infinity');

/**
 * Query for a list of markets.
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query inb
 * @param query ListQuery<C>
 * @returns Promise<MarketList<C>>
 */
const list = async (context, query) => {
    if (types.isFullContext(context) || types.isIndexerContext(context)) {
        return listFromIndexer(context, query);
    }
    else if (types.isRpcContext(context)) {
        return listFromRpc(context, query);
    }
    return [];
};
/**
 * Concrete listing function for indexer context
 * @private
 */
const listFromIndexer = async (context, query) => {
    return (await context.indexer.markets(query)).markets.map(market$1 => market.attachMarketMethods(context, market$1));
};
/**
 * Concrete listing function for rpc context
 * @private
 */
const listFromRpc = async (context, query) => {
    const entries = query && pagination.isPaginated(query)
        ? await context.api.query.marketCommons.markets.entriesPaged({
            args: [],
            pageSize: query.limit,
            startKey: `${query.offset}`,
        })
        : await context.api.query.marketCommons.markets.entries();
    const list = entries.map(([{ args: [marketId], }, market$1,]) => market.rpcMarket(context, marketId, market$1.unwrap()));
    return list;
};

exports.list = list;
//# sourceMappingURL=index.js.map

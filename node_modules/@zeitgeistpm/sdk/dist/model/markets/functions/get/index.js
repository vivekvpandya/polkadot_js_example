'use strict';

var O = require('@zeitgeistpm/utility/dist/option');
var rxjs = require('rxjs');
var types = require('../../../../context/types.js');
var market = require('../../market.js');
require('@zeitgeistpm/utility/dist/infinity');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var O__namespace = /*#__PURE__*/_interopNamespaceDefault(O);

/**
 * Fetch a market by its market id
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query inb
 * @param query MarketQuery
 * @returns Promise<Market<C>>
 */
const get = async (context, query) => {
    if (types.isIndexerContext(context)) {
        return getFromIndexer(context, query);
    }
    else if (types.isRpcContext(context)) {
        return getFromRpc(context, query);
    }
    throw new Error('unrechable code detected.');
};
/**
 * Concrete get function for indexer context
 * @private
 */
const getFromIndexer = async (context, query) => {
    const { markets: [market$1], } = await context.indexer.markets({ where: { marketId_eq: query.marketId } });
    if (market$1) {
        return O__namespace.option(O__namespace.some(market.attachMarketMethods(context, market$1)));
    }
    return O__namespace.option(O__namespace.none());
};
/**
 * Concrete get function for rpc context
 * @private
 */
const getFromRpc = async (context, query) => {
    const market$1 = await context.api.query.marketCommons.markets(query.marketId);
    if (!market$1.isSome)
        O__namespace.option(O__namespace.none());
    return O__namespace.option(O__namespace.some(market.rpcMarket(context, query.marketId, market$1.unwrap())));
};
/**
 * Fetch market and stream changes from rpc.
 *
 * @param context RpcContext<MS>
 * @param query MarketGetQuery
 * @returns Observable<Market<RpcContext, MS>>
 */
const observeMarket$ = (context, query) => {
    return new rxjs.Observable(subscription => {
        const unsub = context.api.query.marketCommons.markets(query.marketId, market$1 => {
            if (!market$1.isSome) {
                return subscription.unsubscribe();
            }
            subscription.next(market.rpcMarket(context, query.marketId, market$1.unwrap()));
        });
        return async () => {
            subscription.unsubscribe();
            unsub.then(unsub => unsub());
        };
    });
};

exports.get = get;
exports.observeMarket$ = observeMarket$;
//# sourceMappingURL=index.js.map

import * as O from '@zeitgeistpm/utility/dist/option';
import { Observable } from 'rxjs';
import { isIndexerContext, isRpcContext } from '../../../../context/types.esm.js';
import { attachMarketMethods, rpcMarket } from '../../market.esm.js';
import '@zeitgeistpm/utility/dist/infinity';

/**
 * Fetch a market by its market id
 * Query capabilities and returned data differentiates between a rpc and indexer context.
 *
 * @generic C - Context
 * @param context C - the context to query inb
 * @param query MarketQuery
 * @returns Promise<Market<C>>
 */
const get = async (context, query) => {
    if (isIndexerContext(context)) {
        return getFromIndexer(context, query);
    }
    else if (isRpcContext(context)) {
        return getFromRpc(context, query);
    }
    throw new Error('unrechable code detected.');
};
/**
 * Concrete get function for indexer context
 * @private
 */
const getFromIndexer = async (context, query) => {
    const { markets: [market], } = await context.indexer.markets({ where: { marketId_eq: query.marketId } });
    if (market) {
        return O.option(O.some(attachMarketMethods(context, market)));
    }
    return O.option(O.none());
};
/**
 * Concrete get function for rpc context
 * @private
 */
const getFromRpc = async (context, query) => {
    const market = await context.api.query.marketCommons.markets(query.marketId);
    if (!market.isSome)
        O.option(O.none());
    return O.option(O.some(rpcMarket(context, query.marketId, market.unwrap())));
};
/**
 * Fetch market and stream changes from rpc.
 *
 * @param context RpcContext<MS>
 * @param query MarketGetQuery
 * @returns Observable<Market<RpcContext, MS>>
 */
const observeMarket$ = (context, query) => {
    return new Observable(subscription => {
        const unsub = context.api.query.marketCommons.markets(query.marketId, market => {
            if (!market.isSome) {
                return subscription.unsubscribe();
            }
            subscription.next(rpcMarket(context, query.marketId, market.unwrap()));
        });
        return async () => {
            subscription.unsubscribe();
            unsub.then(unsub => unsub());
        };
    });
};

export { get, observeMarket$ };
//# sourceMappingURL=index.esm.js.map

import type { Storage } from '@zeitgeistpm/web3.storage';
import type { CID } from 'ipfs-http-client';
import type { CommentMetadata } from './comment';
import type { MarketMetadata } from './market';
/**
 * Generic metadata storage type.
 *
 * @generic M = MarketMetadata
 * @generic C = Comment
 */
export interface MetadataStorage<M extends TaggedMetadata<'markets'> = MarketMetadata, C extends TaggedMetadata<'comments'> = CommentMetadata> {
    /**
     * Storage for Market metadata.
     */
    readonly markets: Storage<M, TaggedID<'markets'>>;
    /**
     * Storage for Market comments.
     * @notes not in use, just testing type narrowing.
     */
    readonly comments: Storage<C, TaggedID<'comments'>>;
    /**
     * Use storage narrowed to a sub storage type.
     *
     * @note for internal usage.
     *
     * @generic K extends keyof this
     * @param key K
     */
    of<K extends keyof this>(key: K): Storage<StorageTypeOf<this[K]>, StorageIdTypeOf<this[K]>>;
}
/**
 * Create a tagged metadata storage object type.
 * @generic T extends keyof MetadataStorage
 */
export declare type TaggedMetadata<T extends keyof MetadataStorage> = {
    __meta: T;
};
/**
 * Create a tagged metadata storage object id.
 * @generic T extends keyof MetadataStorage
 */
export declare type TaggedID<T extends keyof MetadataStorage> = {
    __meta: T;
    cid: CID;
};
/**
 * Type helper to extract the storage type at a given key in a MetadataStorage
 *
 * @generic MS extends MetadataStorage,
 * @generic K extends keyof MSS>
 */
export declare type StorageTypeOf<S> = S extends Storage<infer T, infer ID> ? T : never;
/**
 * Type helper to extract the storage id at a given key in a MetadataStorage
 *
 * @generic MS extends MetadataStorage,
 * @generic K extends keyof MSS>
 */
export declare type StorageIdTypeOf<S> = S extends Storage<infer T, infer ID> ? ID : never;
/**
 * Unpack the inner type of market storage.
 * @generic MS extends MetadataStorage
 */
export declare type MarketTypeOf<MS extends MetadataStorage> = StorageTypeOf<MS['markets']>;
/**
 * Unpack the inner type of market id.
 * @generic MS extends MetadataStorage
 */
export declare type MarketIdTypeOf<MS extends MetadataStorage> = StorageIdTypeOf<MS['markets']>;
/**
 * Utility for creating typed and tagged metadata storage.
 *
 * @generic M extends TaggedMetadata<'markets'> = MarketMetadata - market metadata
 * @generic C extends TaggedMetadata<'comments'> = CommentMetadata - comment metadata
 * @param storage Storage<any, any>
 * @returns
 */
export declare const createStorage: <M extends TaggedMetadata<"markets"> = {
    __meta: "markets";
    slug: string;
    description: string;
    question: string;
    tags?: string[] | undefined;
    confidentialId?: string | undefined;
    img?: string | undefined;
    scalarType?: "number" | "date" | undefined;
    categories?: {
        name: string;
        img?: string | undefined;
        ticker?: string | undefined;
        color?: string | undefined;
    }[] | undefined;
}, C extends TaggedMetadata<"comments"> = CommentMetadata>(storage: Storage<any, any>) => MetadataStorage<M, C>;
/**
 * Create a sturatable metadata storage.
 *
 * @generic MS extends MetadataStorage
 * @param storage M
 * @returns M & SaturatedMetadataStorage<MS>
 */
export declare const saturate: <MS extends MetadataStorage<any, any>>(storage: MS) => MS;
/**
 * Utility to create a tagged metadata storage.
 *
 * @param key keyof MetadataStorage
 * @param storage Storage<T, CID>
 * @returns Storage<any, TaggedID<any>>
 */
export declare const tagged: <T extends TaggedMetadata<any>>(key: keyof MetadataStorage, storage: Storage<T, CID>) => Storage<any, TaggedID<any>>;
//# sourceMappingURL=types.d.ts.map
'use strict';

var Te = require('@zeitgeistpm/utility/dist/taskeither');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var Te__namespace = /*#__PURE__*/_interopNamespaceDefault(Te);

/**
 * Utility for creating typed and tagged metadata storage.
 *
 * @generic M extends TaggedMetadata<'markets'> = MarketMetadata - market metadata
 * @generic C extends TaggedMetadata<'comments'> = CommentMetadata - comment metadata
 * @param storage Storage<any, any>
 * @returns
 */
const createStorage = (storage) => saturate({
    markets: tagged('markets', storage),
    comments: tagged('comments', storage),
});
/**
 * Create a sturatable metadata storage.
 *
 * @generic MS extends MetadataStorage
 * @param storage M
 * @returns M & SaturatedMetadataStorage<MS>
 */
const saturate = (storage) => ({
    ...storage,
    of: key => storage[key],
});
/**
 * Utility to create a tagged metadata storage.
 *
 * @param key keyof MetadataStorage
 * @param storage Storage<T, CID>
 * @returns Storage<any, TaggedID<any>>
 */
const tagged = (key, storage) => ({
    get: ({ cid }) => storage.get(cid),
    del: ({ cid }) => storage.del(cid),
    put: Te__namespace.from(async (data) => {
        const cid = await storage.put(data);
        return {
            __meta: key,
            cid: cid,
        };
    }),
});

exports.createStorage = createStorage;
exports.saturate = saturate;
exports.tagged = tagged;
//# sourceMappingURL=types.js.map

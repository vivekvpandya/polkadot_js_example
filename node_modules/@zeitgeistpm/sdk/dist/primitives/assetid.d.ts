import type { ZeitgeistPrimitivesAsset } from '@polkadot/types/lookup';
import * as E from '@zeitgeistpm/utility/dist/either';
import { Infer } from 'superstruct';
import { MarketId } from './marketid';
/**
 * AssetId.
 * This type delinieates an asset at an index in a market pool.
 */
export declare type AssetId = Infer<typeof IOAssetId>;
export declare type ScalarAssetId = Infer<typeof IOScalarAssetId>;
export declare type CategoricalAssetId = Infer<typeof IOCategoricalAssetId>;
export declare type ZtgAssetId = Infer<typeof IOZtgAssetId>;
export declare type PoolShareAssetId = Infer<typeof IOPoolShareAssetId>;
export declare type MarketOutcomeAssetId = Infer<typeof IOMarketOutcomeAssetId>;
export declare type ScalarIndex = Infer<typeof IOScalarIndex>;
export declare type CategoricalIndex = Infer<typeof IOCategoricalIndex>;
export declare type ScalarPosition = Infer<typeof IOScalarPosition>;
/**
 * Io types for the asset ids.
 * Usefull for decoding from a string or json object.
 */
export declare const IOScalarPosition: import("superstruct").Struct<"Short" | "Long", null>;
export declare const IOCategoricalIndex: import("superstruct").Struct<[MarketId, number], null>;
export declare const IOScalarIndex: import("superstruct").Struct<[MarketId, "Short" | "Long"], null>;
export declare const IOCategoricalAssetId: import("superstruct").Struct<{
    CategoricalOutcome: [MarketId, number];
}, {
    CategoricalOutcome: import("superstruct").Struct<[MarketId, number], null>;
}>;
export declare const IOScalarAssetId: import("superstruct").Struct<{
    ScalarOutcome: [MarketId, "Short" | "Long"];
}, {
    ScalarOutcome: import("superstruct").Struct<[MarketId, "Short" | "Long"], null>;
}>;
export declare const IOMarketOutcomeAssetId: import("superstruct").Struct<{
    CategoricalOutcome: [MarketId, number];
} | {
    ScalarOutcome: [MarketId, "Short" | "Long"];
}, null>;
export declare const IOZtgAssetId: import("superstruct").Struct<{
    Ztg: null;
}, {
    Ztg: import("superstruct").Struct<null, null>;
}>;
export declare const IOPoolShareAssetId: import("superstruct").Struct<{
    PoolShare: number;
}, {
    PoolShare: import("superstruct").Struct<number, null>;
}>;
export declare const IOAssetId: import("superstruct").Struct<{
    CategoricalOutcome: [MarketId, number];
} | {
    ScalarOutcome: [MarketId, "Short" | "Long"];
} | {
    Ztg: null;
} | {
    PoolShare: number;
}, null>;
export declare const fromPrimitive: (asset: ZeitgeistPrimitivesAsset) => AssetId;
/**
 * Get the MarketId of a scalar or categorical asset id.
 *
 * @param assetId ScalarAssetId | CategoricalAssetId
 * @returns MarketId
 */
export declare const getMarketIdOf: (assetId: ScalarAssetId | CategoricalAssetId) => MarketId;
/**
 * Get asset index of a scalar asset, short being 0 and long being 1
 *
 * @param scalarAssetId ScalarAssetId
 * @returns number
 */
export declare const getScalarIndexOf: (scalarAssetId: ScalarAssetId) => number;
/**
 * Get the asset index of an AssetId, will return index only for scalar and categorical assets.
 *
 * @param assetId AssetId
 * @returns number | null
 */
export declare const getIndexOf: (assetId: AssetId) => number | null;
/**
 * Convert a indexer asset id string or object to an AssetId.
 *
 * TODO: should return an Either since parsing can fail. Users expect parsing to work, not working is an exception.
 *
 * @param raw object | string
 * @returns O.IOption<AssetId>
 */
export declare const parseAssetId: (raw: string | object) => E.IEither<SyntaxError, AssetId>;
//# sourceMappingURL=assetid.d.ts.map
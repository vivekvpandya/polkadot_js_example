import * as E from '@zeitgeistpm/utility/dist/either';
import { upperFirstObjectKeys } from '@zeitgeistpm/utility/dist/object';
import * as O from '@zeitgeistpm/utility/dist/option';
import { union, literal, tuple, number, type } from 'superstruct';
import { IOMarketId } from './marketid.mjs';

/**
 * Io types for the asset ids.
 * Usefull for decoding from a string or json object.
 */
const IOScalarPosition = union([literal('Short'), literal('Long')]);
const IOCategoricalIndex = tuple([IOMarketId, number()]);
const IOScalarIndex = tuple([IOMarketId, IOScalarPosition]);
const IOCategoricalAssetId = type({
    CategoricalOutcome: IOCategoricalIndex,
});
const IOScalarAssetId = type({
    ScalarOutcome: IOScalarIndex,
});
const IOMarketOutcomeAssetId = union([IOCategoricalAssetId, IOScalarAssetId]);
const IOZtgAssetId = type({
    Ztg: literal(null),
});
const IOPoolShareAssetId = type({
    PoolShare: number(),
});
const IOAssetId = union([
    IOCategoricalAssetId,
    IOScalarAssetId,
    IOZtgAssetId,
    IOPoolShareAssetId,
]);
const fromPrimitive = (asset) => {
    if (asset.isCategoricalOutcome) {
        return {
            CategoricalOutcome: [
                asset.asCategoricalOutcome[0].toNumber(),
                asset.asCategoricalOutcome[1].toNumber(),
            ],
        };
    }
    else if (asset.isScalarOutcome) {
        return {
            ScalarOutcome: [
                asset.asScalarOutcome[0].toNumber(),
                asset.asScalarOutcome[1].type,
            ],
        };
    }
    else if (asset.isPoolShare) {
        return { PoolShare: asset.asPoolShare.toNumber() };
    }
    return { Ztg: null };
};
/**
 * Get the MarketId of a scalar or categorical asset id.
 *
 * @param assetId ScalarAssetId | CategoricalAssetId
 * @returns MarketId
 */
const getMarketIdOf = (assetId) => IOScalarAssetId.is(assetId) ? assetId.ScalarOutcome[0] : assetId.CategoricalOutcome[0];
/**
 * Get asset index of a scalar asset, short being 0 and long being 1
 *
 * @param scalarAssetId ScalarAssetId
 * @returns number
 */
const getScalarIndexOf = (scalarAssetId) => scalarAssetId.ScalarOutcome[1] === 'Short' ? 1 : 0;
/**
 * Get the asset index of an AssetId, will return index only for scalar and categorical assets.
 *
 * @param assetId AssetId
 * @returns number | null
 */
const getIndexOf = (assetId) => IOCategoricalAssetId.is(assetId)
    ? assetId.CategoricalOutcome[1]
    : IOScalarAssetId.is(assetId)
        ? getScalarIndexOf(assetId)
        : null;
/**
 * Convert a indexer asset id string or object to an AssetId.
 *
 * TODO: should return an Either since parsing can fail. Users expect parsing to work, not working is an exception.
 *
 * @param raw object | string
 * @returns O.IOption<AssetId>
 */
const parseAssetId = (raw) => {
    if (typeof raw === 'string' && raw.toLowerCase() === 'ztg') {
        return E.either(E.right({
            Ztg: null,
        }));
    }
    const parsed = O.tryCatch(() => (typeof raw === 'object' ? raw : JSON.parse(raw)));
    if (O.isNone(parsed))
        return E.either(E.left(new SyntaxError('Invalid asset id json')));
    const obj = upperFirstObjectKeys(parsed.value);
    let assetId = null;
    if ('Ztg' in obj) {
        assetId = {
            Ztg: null,
        };
    }
    if ('CategoricalOutcome' in obj) {
        assetId = {
            CategoricalOutcome: obj['CategoricalOutcome'],
        };
    }
    if ('ScalarOutcome' in obj) {
        assetId = {
            ScalarOutcome: obj['ScalarOutcome'],
        };
    }
    if ('PoolShare' in obj) {
        assetId = {
            PoolShare: obj['PoolShare'],
        };
    }
    return E.either(assetId ? E.right(assetId) : E.left(new SyntaxError('Invalid asset id structure')));
};

export { IOAssetId, IOCategoricalAssetId, IOCategoricalIndex, IOMarketOutcomeAssetId, IOPoolShareAssetId, IOScalarAssetId, IOScalarIndex, IOScalarPosition, IOZtgAssetId, fromPrimitive, getIndexOf, getMarketIdOf, getScalarIndexOf, parseAssetId };
//# sourceMappingURL=assetid.mjs.map

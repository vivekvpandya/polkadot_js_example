'use strict';

var E = require('@zeitgeistpm/utility/dist/either');
var object = require('@zeitgeistpm/utility/dist/object');
var O = require('@zeitgeistpm/utility/dist/option');
var superstruct = require('superstruct');
var marketid = require('./marketid.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var E__namespace = /*#__PURE__*/_interopNamespaceDefault(E);
var O__namespace = /*#__PURE__*/_interopNamespaceDefault(O);

/**
 * Io types for the asset ids.
 * Usefull for decoding from a string or json object.
 */
const IOScalarPosition = superstruct.union([superstruct.literal('Short'), superstruct.literal('Long')]);
const IOCategoricalIndex = superstruct.tuple([marketid.IOMarketId, superstruct.number()]);
const IOScalarIndex = superstruct.tuple([marketid.IOMarketId, IOScalarPosition]);
const IOCategoricalAssetId = superstruct.type({
    CategoricalOutcome: IOCategoricalIndex,
});
const IOScalarAssetId = superstruct.type({
    ScalarOutcome: IOScalarIndex,
});
const IOMarketOutcomeAssetId = superstruct.union([IOCategoricalAssetId, IOScalarAssetId]);
const IOZtgAssetId = superstruct.type({
    Ztg: superstruct.literal(null),
});
const IOPoolShareAssetId = superstruct.type({
    PoolShare: superstruct.number(),
});
const IOAssetId = superstruct.union([
    IOCategoricalAssetId,
    IOScalarAssetId,
    IOZtgAssetId,
    IOPoolShareAssetId,
]);
const fromPrimitive = (asset) => {
    if (asset.isCategoricalOutcome) {
        return {
            CategoricalOutcome: [
                asset.asCategoricalOutcome[0].toNumber(),
                asset.asCategoricalOutcome[1].toNumber(),
            ],
        };
    }
    else if (asset.isScalarOutcome) {
        return {
            ScalarOutcome: [
                asset.asScalarOutcome[0].toNumber(),
                asset.asScalarOutcome[1].type,
            ],
        };
    }
    else if (asset.isPoolShare) {
        return { PoolShare: asset.asPoolShare.toNumber() };
    }
    return { Ztg: null };
};
/**
 * Get the MarketId of a scalar or categorical asset id.
 *
 * @param assetId ScalarAssetId | CategoricalAssetId
 * @returns MarketId
 */
const getMarketIdOf = (assetId) => IOScalarAssetId.is(assetId) ? assetId.ScalarOutcome[0] : assetId.CategoricalOutcome[0];
/**
 * Get asset index of a scalar asset, short being 0 and long being 1
 *
 * @param scalarAssetId ScalarAssetId
 * @returns number
 */
const getScalarIndexOf = (scalarAssetId) => scalarAssetId.ScalarOutcome[1] === 'Short' ? 1 : 0;
/**
 * Get the asset index of an AssetId, will return index only for scalar and categorical assets.
 *
 * @param assetId AssetId
 * @returns number | null
 */
const getIndexOf = (assetId) => IOCategoricalAssetId.is(assetId)
    ? assetId.CategoricalOutcome[1]
    : IOScalarAssetId.is(assetId)
        ? getScalarIndexOf(assetId)
        : null;
/**
 * Convert a indexer asset id string or object to an AssetId.
 *
 * TODO: should return an Either since parsing can fail. Users expect parsing to work, not working is an exception.
 *
 * @param raw object | string
 * @returns O.IOption<AssetId>
 */
const parseAssetId = (raw) => {
    if (typeof raw === 'string' && raw.toLowerCase() === 'ztg') {
        return E__namespace.either(E__namespace.right({
            Ztg: null,
        }));
    }
    const parsed = O__namespace.tryCatch(() => (typeof raw === 'object' ? raw : JSON.parse(raw)));
    if (O__namespace.isNone(parsed))
        return E__namespace.either(E__namespace.left(new SyntaxError('Invalid asset id json')));
    const obj = object.upperFirstObjectKeys(parsed.value);
    let assetId = null;
    if ('Ztg' in obj) {
        assetId = {
            Ztg: null,
        };
    }
    if ('CategoricalOutcome' in obj) {
        assetId = {
            CategoricalOutcome: obj['CategoricalOutcome'],
        };
    }
    if ('ScalarOutcome' in obj) {
        assetId = {
            ScalarOutcome: obj['ScalarOutcome'],
        };
    }
    if ('PoolShare' in obj) {
        assetId = {
            PoolShare: obj['PoolShare'],
        };
    }
    return E__namespace.either(assetId ? E__namespace.right(assetId) : E__namespace.left(new SyntaxError('Invalid asset id structure')));
};

exports.IOAssetId = IOAssetId;
exports.IOCategoricalAssetId = IOCategoricalAssetId;
exports.IOCategoricalIndex = IOCategoricalIndex;
exports.IOMarketOutcomeAssetId = IOMarketOutcomeAssetId;
exports.IOPoolShareAssetId = IOPoolShareAssetId;
exports.IOScalarAssetId = IOScalarAssetId;
exports.IOScalarIndex = IOScalarIndex;
exports.IOScalarPosition = IOScalarPosition;
exports.IOZtgAssetId = IOZtgAssetId;
exports.fromPrimitive = fromPrimitive;
exports.getIndexOf = getIndexOf;
exports.getMarketIdOf = getMarketIdOf;
exports.getScalarIndexOf = getScalarIndexOf;
exports.parseAssetId = parseAssetId;
//# sourceMappingURL=assetid.js.map

{"version":3,"file":"assetid.esm.js","sources":["../../src/primitives/assetid.ts"],"sourcesContent":["import type { ZeitgeistPrimitivesAsset } from '@polkadot/types/lookup'\nimport * as E from '@zeitgeistpm/utility/dist/either'\nimport { upperFirstObjectKeys } from '@zeitgeistpm/utility/dist/object'\nimport * as O from '@zeitgeistpm/utility/dist/option'\nimport { Infer, literal, number, tuple, type, union } from 'superstruct'\nimport { IOMarketId, MarketId } from './marketid'\n\n/**\n * AssetId.\n * This type delinieates an asset at an index in a market pool.\n */\nexport type AssetId = Infer<typeof IOAssetId>\nexport type ScalarAssetId = Infer<typeof IOScalarAssetId>\nexport type CategoricalAssetId = Infer<typeof IOCategoricalAssetId>\nexport type ZtgAssetId = Infer<typeof IOZtgAssetId>\nexport type PoolShareAssetId = Infer<typeof IOPoolShareAssetId>\n\nexport type MarketOutcomeAssetId = Infer<typeof IOMarketOutcomeAssetId>\n\nexport type ScalarIndex = Infer<typeof IOScalarIndex>\nexport type CategoricalIndex = Infer<typeof IOCategoricalIndex>\nexport type ScalarPosition = Infer<typeof IOScalarPosition>\n\n/**\n * Io types for the asset ids.\n * Usefull for decoding from a string or json object.\n */\n\nexport const IOScalarPosition = union([literal('Short'), literal('Long')])\n\nexport const IOCategoricalIndex = tuple([IOMarketId, number()])\nexport const IOScalarIndex = tuple([IOMarketId, IOScalarPosition])\n\nexport const IOCategoricalAssetId = type({\n  CategoricalOutcome: IOCategoricalIndex,\n})\n\nexport const IOScalarAssetId = type({\n  ScalarOutcome: IOScalarIndex,\n})\n\nexport const IOMarketOutcomeAssetId = union([IOCategoricalAssetId, IOScalarAssetId])\n\nexport const IOZtgAssetId = type({\n  Ztg: literal(null),\n})\n\nexport const IOPoolShareAssetId = type({\n  PoolShare: number(),\n})\n\nexport const IOAssetId = union([\n  IOCategoricalAssetId,\n  IOScalarAssetId,\n  IOZtgAssetId,\n  IOPoolShareAssetId,\n])\n\nexport const fromPrimitive = (asset: ZeitgeistPrimitivesAsset): AssetId => {\n  if (asset.isCategoricalOutcome) {\n    return {\n      CategoricalOutcome: [\n        asset.asCategoricalOutcome[0].toNumber() as MarketId,\n        asset.asCategoricalOutcome[1].toNumber(),\n      ],\n    }\n  } else if (asset.isScalarOutcome) {\n    return {\n      ScalarOutcome: [\n        asset.asScalarOutcome[0].toNumber() as MarketId,\n        asset.asScalarOutcome[1].type,\n      ],\n    }\n  } else if (asset.isPoolShare) {\n    return { PoolShare: asset.asPoolShare.toNumber() }\n  }\n  return { Ztg: null }\n}\n\n/**\n * Get the MarketId of a scalar or categorical asset id.\n *\n * @param assetId ScalarAssetId | CategoricalAssetId\n * @returns MarketId\n */\nexport const getMarketIdOf = (assetId: ScalarAssetId | CategoricalAssetId): MarketId =>\n  IOScalarAssetId.is(assetId) ? assetId.ScalarOutcome[0] : assetId.CategoricalOutcome[0]\n\n/**\n * Get asset index of a scalar asset, short being 0 and long being 1\n *\n * @param scalarAssetId ScalarAssetId\n * @returns number\n */\nexport const getScalarIndexOf = (scalarAssetId: ScalarAssetId): number =>\n  scalarAssetId.ScalarOutcome[1] === 'Short' ? 1 : 0\n\n/**\n * Get the asset index of an AssetId, will return index only for scalar and categorical assets.\n *\n * @param assetId AssetId\n * @returns number | null\n */\nexport const getIndexOf = (assetId: AssetId): number | null =>\n  IOCategoricalAssetId.is(assetId)\n    ? assetId.CategoricalOutcome[1]\n    : IOScalarAssetId.is(assetId)\n    ? getScalarIndexOf(assetId)\n    : null\n\n/**\n * Convert a indexer asset id string or object to an AssetId.\n *\n * TODO: should return an Either since parsing can fail. Users expect parsing to work, not working is an exception.\n *\n * @param raw object | string\n * @returns O.IOption<AssetId>\n */\nexport const parseAssetId = (raw: string | object): E.IEither<SyntaxError, AssetId> => {\n  if (typeof raw === 'string' && raw.toLowerCase() === 'ztg') {\n    return E.either(\n      E.right({\n        Ztg: null,\n      } as AssetId),\n    )\n  }\n\n  const parsed = O.tryCatch(() => (typeof raw === 'object' ? raw : JSON.parse(raw)))\n  if (O.isNone(parsed)) return E.either(E.left(new SyntaxError('Invalid asset id json')))\n\n  const obj: any = upperFirstObjectKeys(parsed.value)\n  let assetId: AssetId | null = null\n\n  if ('Ztg' in obj) {\n    assetId = {\n      Ztg: null,\n    } as AssetId\n  }\n  if ('CategoricalOutcome' in obj) {\n    assetId = {\n      CategoricalOutcome: obj['CategoricalOutcome'],\n    } as AssetId\n  }\n  if ('ScalarOutcome' in obj) {\n    assetId = {\n      ScalarOutcome: obj['ScalarOutcome'],\n    } as AssetId\n  }\n  if ('PoolShare' in obj) {\n    assetId = {\n      PoolShare: obj['PoolShare'],\n    } as AssetId\n  }\n\n  return E.either(\n    assetId ? E.right(assetId) : E.left(new SyntaxError('Invalid asset id structure')),\n  )\n}\n"],"names":[],"mappings":"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"}
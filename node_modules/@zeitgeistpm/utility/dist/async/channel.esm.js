import { isDeferred, deferred } from './deferred.esm.js';

/**
 * A returned value type. Terminates the channel.
 */
const returned = Symbol();
/**
 * Type guard for returned values.
 *
 * @generic T - value type of channel
 * @param value unknwon
 * @returns value is Returned<T>
 */
const isReturned = (value) => typeof value === 'object' && value !== null && returned in value;
/**
 * Create a new channel of type T
 *
 * @generic T - value type of channel
 * @param buffer Array<T | Deferred<T> | Returned<T>>
 * @returns Channel<T>
 */
const channel = (buffer = []) => {
    let terminated = false;
    const put = (value) => {
        if (terminated)
            throw new Error(`Trying to put value ${value} to terminated channel.`);
        const taker = buffer[0] && isDeferred(buffer[0]) ? buffer[0] : null;
        if (taker) {
            buffer.splice(0, 1);
            return taker.resolve(value);
        }
        if (isReturned(value)) {
            return buffer.push(value);
        }
        return buffer.push(value);
    };
    const end = (value) => {
        put({ [returned]: value });
    };
    const take = async () => {
        if (terminated)
            throw new Error(`Trying to take value from terminated channel.`);
        const next = buffer.shift();
        terminated = isReturned(next);
        if (next && isDeferred(next)) {
            return next.value;
        }
        else if (next) {
            return next;
        }
        else {
            const out = deferred();
            buffer.push(out);
            return out.value;
        }
    };
    async function* generator() {
        if (terminated)
            throw new Error(`Trying to create generator from terminated channel.`);
        while (true) {
            const value = await take();
            if (!isReturned(value)) {
                yield value;
                continue;
            }
            yield value[returned];
            break;
        }
    }
    return {
        put,
        end,
        take: () => take().then(value => (isReturned(value) ? value[returned] : value)),
        [Symbol.asyncIterator]: generator,
        then: async (resolve) => {
            while (true) {
                const out = await take();
                if (isReturned(out)) {
                    resolve?.(out[returned]);
                }
            }
        },
    };
};

export { channel, isReturned, returned };
//# sourceMappingURL=channel.esm.js.map

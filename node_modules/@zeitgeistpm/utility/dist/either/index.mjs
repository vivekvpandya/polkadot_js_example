import { isFunction } from '@polkadot/util/is/function';
import { throws } from '../error/index.mjs';
import { option, some, none } from '../option/index.mjs';

/**
 * Create a Right with value.
 */
const right = (right) => ({
    right,
});
/**
 * Create a Left with value.
 */
const left = (left) => ({
    left,
});
const isEither = (obj) => typeof obj === 'object' && obj && (isRight(obj) || isLeft(obj));
/**
 * Typeguard for right values
 */
const isRight = (either) => 'right' in either;
/**
 * Typeguard for left values
 */
const isLeft = (either) => 'left' in either;
/**
 * Unwrap the right value. Throws if the either is a left.
 */
const unwrap = (either) => unrightOr(throws, either);
/**
 * Unwrap the right value. Throws if the either is a left.
 */
const unwrapLeft = (either) => unleftOr(throws, either);
/**
 * Maps the right value if present with the mapping function.
 *
 * @example ```typescript
 * map(right(1), num => num + 1) === right(2)
 * map(left("error"), num => num + 1) === left("error")
 * ```
 */
const map = (f, either) => isLeft(either) ? either : right(f(either.right));
/**
 * Chains eithers, where it returns out a Left if one of the composed functions returns left.
 * Or return the Right value if all succeedes with the composed value from the last chain computation.
 *
 * @example
 * ```typescript
 * const validate = (str: string) =>
 *   str === 'correct' ? right(1) : left(new Error('string has to be "correct"'))
 *
 * chain(validate, right('correct'))
 *   .unrightOr(throws) // -> 1
 *
 * chain(validate, left('error'))
 *   .unrightOr(throws) // -> throws error
 * ```
 * ```
 */
const bind = (f, either) => {
    if (isLeft(either)) {
        return either;
    }
    const next = f(either.right);
    if (isEither(next)) {
        return next;
    }
    return right(next);
};
/**
 * Unwraps a the right value into an Option<R>
 *
 * @example ```typescript
 * unright(right(1)).unwrapOr(2) === 1
 * unright(left(NaN)).unwrapOr(2) === 2
 * ```
 */
const unright = (either) => option(isRight(either) ? some(either.right) : none());
/**
 * Unwraps a the left value into an Option<L>
 *
 * @example ```typescript
 * unleft(right(1)).unwrapOr(2) === 2
 * unleft(left(NaN)).unwrapOr(2) === NaN
 * ```
 */
const unleft = (either) => option(isLeft(either) ? some(either.left) : none());
/**
 * Tries to unwrap the right value or uses the default value or lazy function
 * to produce the correct result.
 *
 * @example ```typescript
 *   unrightOr(right(1), 2) // -> 1
 *   unrightOr(left(NaN), 2) // -> 2
 * ```
 */
const unrightOr = (or, either) => isRight(either) ? either.right : isFunction(or) ? or(either.left) : or;
/**
 * Tries to unwrap the left value or uses the default value or lazy function
 * to produce the correct result.
 *
 * @example ```typescript
 *   unleftOr(right(1), 2) // -> 2
 *   unleftOr(left(NaN), 2) // -> NaN
 * ```
 */
const unleftOr = (or, either) => isLeft(either) ? either.left : isFunction(or) ? or(either.right) : or;
/**
 * Bind methods to a Either object for utility and "syntactic" sugar.
 *
 * @param _either Either<L, R>
 * @returns EitherInterface<L, R>
 */
const either = (_either) => ({
    ..._either,
    unwrap: () => unwrap(_either),
    unwrapLeft: () => unwrapLeft(_either),
    unright: () => unright(_either),
    unleft: () => unleft(_either),
    unrightOr: (or) => unrightOr(or, _either),
    unleftOr: (or) => unleftOr(or, _either),
    map: (f) => either(map(f, _either)),
    bind: (f) => either(bind(f, _either)),
    isRight: () => (isRight(_either) ? either(_either) : null),
    isLeft: () => (isLeft(_either) ? either(_either) : null),
});
/**
 * Tries a function and converts the caught error to Left or returned value to Right.
 *
 * @param fn () => R - function to try catch
 * @returns Either<Error, R>
 */
const tryCatch = (fn) => {
    try {
        return either(right(fn()));
    }
    catch (error) {
        return either(left(error));
    }
};

export { bind, either, isEither, isLeft, isRight, left, map, right, tryCatch, unleft, unleftOr, unright, unrightOr, unwrap, unwrapLeft };
//# sourceMappingURL=index.mjs.map

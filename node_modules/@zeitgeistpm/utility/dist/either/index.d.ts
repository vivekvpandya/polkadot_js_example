import * as O from '../option';
/**
 * Either type.
 *
 * Can represent either a left or a right value. Used often in
 * error handling where something can either succeede(R) or fail(L).
 */
export declare type Either<L, R> = Left<L> | Right<R>;
export declare type Right<R> = {
    right: R;
};
export declare type Left<L> = {
    left: L;
};
/**
 * Create a Right with value.
 */
export declare const right: <A>(right: A) => Right<A>;
/**
 * Create a Left with value.
 */
export declare const left: <A>(left: A) => Left<A>;
export declare const isEither: (obj: any) => obj is Either<any, any>;
/**
 * Typeguard for right values
 */
export declare const isRight: <L, R>(either: Either<L, R>) => either is Right<R>;
/**
 * Typeguard for left values
 */
export declare const isLeft: <L, R>(either: Either<L, R>) => either is Left<L>;
/**
 * Unwrap the right value. Throws if the either is a left.
 */
export declare const unwrap: <L, R>(either: Either<L, R>) => R;
/**
 * Unwrap the right value. Throws if the either is a left.
 */
export declare const unwrapLeft: <L, R>(either: Either<L, R>) => L;
/**
 * Maps the right value if present with the mapping function.
 *
 * @example ```typescript
 * map(right(1), num => num + 1) === right(2)
 * map(left("error"), num => num + 1) === left("error")
 * ```
 */
export declare const map: <L, R, B>(f: (a: R) => B, either: Either<L, R>) => Either<L, B>;
/**
 * Chains eithers, where it returns out a Left if one of the composed functions returns left.
 * Or return the Right value if all succeedes with the composed value from the last chain computation.
 *
 * @example
 * ```typescript
 * const validate = (str: string) =>
 *   str === 'correct' ? right(1) : left(new Error('string has to be "correct"'))
 *
 * chain(validate, right('correct'))
 *   .unrightOr(throws) // -> 1
 *
 * chain(validate, left('error'))
 *   .unrightOr(throws) // -> throws error
 * ```
 * ```
 */
export declare const bind: <L, R, B>(f: (a: R) => B | Either<L, B>, either: Either<L, R>) => Either<L, B>;
/**
 * Unwraps a the right value into an Option<R>
 *
 * @example ```typescript
 * unright(right(1)).unwrapOr(2) === 1
 * unright(left(NaN)).unwrapOr(2) === 2
 * ```
 */
export declare const unright: <L, R>(either: Either<L, R>) => O.IOption<R>;
/**
 * Unwraps a the left value into an Option<L>
 *
 * @example ```typescript
 * unleft(right(1)).unwrapOr(2) === 2
 * unleft(left(NaN)).unwrapOr(2) === NaN
 * ```
 */
export declare const unleft: <L, R>(either: Either<L, R>) => O.IOption<L>;
/**
 * @generic P - the input value, in case of Left it will be R and vice versa.
 */
export declare type OrHandler<P, A> = A | ((value: P) => A);
/**
 * Tries to unwrap the right value or uses the default value or lazy function
 * to produce the correct result.
 *
 * @example ```typescript
 *   unrightOr(right(1), 2) // -> 1
 *   unrightOr(left(NaN), 2) // -> 2
 * ```
 */
export declare const unrightOr: <L, R>(or: OrHandler<L, R>, either: Either<L, R>) => R;
/**
 * Tries to unwrap the left value or uses the default value or lazy function
 * to produce the correct result.
 *
 * @example ```typescript
 *   unleftOr(right(1), 2) // -> 2
 *   unleftOr(left(NaN), 2) // -> NaN
 * ```
 */
export declare const unleftOr: <L, R>(or: OrHandler<R, L>, either: Either<L, R>) => L;
/**
 * Interface over either to call either methods directly on Either objects that implements it.
 */
export declare type IEither<L, R> = Either<L, R> & {
    /**
     * Tries to unwrap the right value. Throws error if value is left.
     * @throws Error
     */
    unwrap: () => R;
    /**
     * Tries to unwrap the left value. Throws error if value is right.
     * @throws Error
     */
    unwrapLeft: () => L;
    /**
     * Unwraps a the right value into an Option<R>
     */
    unright: () => O.IOption<R>;
    /**
     * Unwraps a the left value into an Option<L>
     */
    unleft: () => O.IOption<L>;
    /**
     * Tries to unwrap the right value or uses the default value or lazy function
     * to produce the correct result(or throw error).
     */
    unrightOr: (or: OrHandler<L, R>) => R;
    /**
     * Tries to unwrap the left value or uses the default value or lazy function
     * to produce the correct result.
     */
    unleftOr: (or: OrHandler<R, L>) => L;
    /**
     * Maps the right value if present with the mapping function.
     */
    map: <B>(f: (a: R) => B) => IEither<L, B>;
    /**
     * Chains eithers where it returns out a Left if one of the composed functions returns left
     * or the Right value if all succeedes.
     */
    bind: <B>(f: (a: R) => Either<L, B> | B) => IEither<L, B>;
    /**
     * Boolean check if value is right
     *
     * @returns boolean & E.IEither<L, R>
     */
    isRight: () => null | IEither<L, R>;
    /**
     * Boolean check if value is left
     *
     * @returns boolean & E.IEither<L, R>
     */
    isLeft: () => null | IEither<L, R>;
};
/**
 * Bind methods to a Either object for utility and "syntactic" sugar.
 *
 * @param _either Either<L, R>
 * @returns EitherInterface<L, R>
 */
export declare const either: <L, R>(_either: Either<L, R>) => IEither<L, R>;
/**
 * Tries a function and converts the caught error to Left or returned value to Right.
 *
 * @param fn () => R - function to try catch
 * @returns Either<Error, R>
 */
export declare const tryCatch: <Error_1, R>(fn: () => R) => IEither<Error_1, R>;
//# sourceMappingURL=index.d.ts.map
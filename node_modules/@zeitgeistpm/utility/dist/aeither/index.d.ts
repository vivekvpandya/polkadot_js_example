import * as E from '../either';
import * as O from '../option';
/**
 * Async Either type.
 */
export declare type AEither<L, R> = Promise<E.IEither<L, R>>;
/**
 * Convert a promise to an async either.
 *
 * @generic L - left type
 * @generic R - right type
 * @param promise Promise<R>
 * @returns AEither<L, R>
 */
export declare const from: <L, R>(f: () => Promise<R>) => IAEither<L, R>;
/**
 * Tries to unwrap the right value into a promised right value. Throws error if value is left.
 * @throws Error
 *
 * @returns Promise<R>
 */
export declare const unwrap: <L, R>(either: AEither<L, R>) => Promise<R>;
/**
 * Tries to unwrap the left value into a promised left value. Throws error if value is right.
 * @throws Error
 *
 * @returns Promise<L>
 */
export declare const unwrapLeft: <L, R>(either: AEither<L, R>) => Promise<L>;
/**
 * Unwraps a the right value into an optional value ignoring lefts by returning `none`
 *
 * @returns Promise<O.IOption<R>>
 */
export declare const unright: <L, R>(either: AEither<L, R>) => Promise<O.IOption<R>>;
/**
 * Unwraps a the left value into an optional value ignoring rights by returning `none`
 *
 * @returns Promise<O.IOption<L>>
 */
export declare const unleft: <L, R>(either: AEither<L, R>) => Promise<O.IOption<L>>;
/**
 * Tries to unwrap the right value or uses the default value or lazy function
 * to produce the correct result(or throw error).
 *
 * @returns Promise<R>
 */
export declare const unrightOr: <L, R>(or: OrHandler<L, R>, either: AEither<L, R>) => Promise<R>;
/**
 * Tries to unwrap the left value or uses the default value or lazy function
 * to produce the correct result.
 *
 * @returns Promise<L>
 */
export declare const unleftOr: <L, R>(or: OrHandler<R, L>, either: AEither<L, R>) => Promise<L>;
/**
 * Maps the right value if present with the mapping function.
 *
 * @returns IAEither<L, B>
 */
export declare const map: <L, R, B>(f: (a: R) => B, either: AEither<L, R>) => AEither<L, B>;
/**
 * Chains eithers where it returns out a Left if one of the composed functions returns left
 * or the Right value if all succeedes.
 *
 * @returns IAEither<L, B>
 */
export declare const bind: <L, R, B>(f: (a: R) => AEither<L, B> | Promise<B>, either: AEither<L, R>) => AEither<L, B>;
/**
 * Interface over AEither to call methods directly on Either objects that implements it.
 */
export declare type IAEither<L, R> = {
    /**
     * Tries to unwrap the right value into a promised right value. Throws error if value is left.
     * @throws Error
     *
     * @returns Promise<R>
     */
    unwrap: () => Promise<R>;
    /**
     * Tries to unwrap the left value into a promised left value. Throws error if value is right.
     * @throws Error
     *
     * @returns Promise<L>
     */
    unwrapLeft: () => Promise<L>;
    /**
     * Unwraps a the right value into an optional value ignoring lefts by returning `none`
     *
     * @returns Promise<O.IOption<R>>
     */
    unright: () => Promise<O.IOption<R>>;
    /**
     * Unwraps a the left value into an optional value ignoring rights by returning `none`
     *
     * @returns Promise<O.IOption<L>>
     */
    unleft: () => Promise<O.IOption<L>>;
    /**
     * Tries to unwrap the right value or uses the default value or lazy function
     * to produce the correct result(or throw error).
     *
     * @returns Promise<R>
     */
    unrightOr: (or: OrHandler<L, R>) => Promise<R>;
    /**
     * Tries to unwrap the left value or uses the default value or lazy function
     * to produce the correct result.
     *
     * @returns Promise<L>
     */
    unleftOr: (or: OrHandler<R, L>) => Promise<L>;
    /**
     * Maps the right value if present with the mapping function.
     *
     * @returns IAEither<L, B>
     */
    map: <B>(f: (a: R) => B) => IAEither<L, B>;
    /**
     * Chains eithers where it returns out a Left if one of the composed functions returns left
     * or the Right value if all succeedes.
     *
     * @returns IAEither<L, B>
     */
    bind: <B>(f: (a: R) => AEither<L, B> | Promise<B>) => IAEither<L, B>;
    /**
     * Return the raw either async.
     *
     * @returns Promise<E.IEither<L, R>>
     */
    asEither: () => Promise<E.IEither<L, R>>;
    /**
     * Boolean check if value is right
     *
     * @returns Promise<false | E.IEither<L, R>>
     */
    isRight: () => Promise<null | E.IEither<L, R>>;
    /**
     * Boolean check if value is left
     *
     * @returns Promise<false | E.IEither<L, R>>
     */
    isLeft: () => Promise<null | E.IEither<L, R>>;
} & Promise<R>;
/**
 * Or handler for async either values.
 *
 * @generic P - the input value, in case of Left it will be R and vice versa.
 */
export declare type OrHandler<P, A> = A | ((value: P) => A);
/**
 * Bind methods to a AEither object for utility and "syntactic" sugar over async eithers..
 *
 * @param _either AEither<L, R>
 * @returns IAEither<L, R>
 */
export declare const aeither: <L, R>(_either: AEither<L, R>) => IAEither<L, R>;
//# sourceMappingURL=index.d.ts.map
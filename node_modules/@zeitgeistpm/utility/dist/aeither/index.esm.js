import { either, right, left, unrightOr as unrightOr$1, unleftOr as unleftOr$1, unright as unright$1, unleft as unleft$1, unwrap as unwrap$1, isRight, isLeft } from '../either/index.esm.js';
import { throws } from '../error/index.esm.js';

/**
 * Convert a promise to an async either.
 *
 * @generic L - left type
 * @generic R - right type
 * @param promise Promise<R>
 * @returns AEither<L, R>
 */
const from = (f) => {
    return aeither(new Promise(async (resolve) => {
        try {
            const value = await f();
            resolve(either(right(value)));
        }
        catch (error) {
            resolve(either(left(error)));
        }
    }));
};
/**
 * Tries to unwrap the right value into a promised right value. Throws error if value is left.
 * @throws Error
 *
 * @returns Promise<R>
 */
const unwrap = async (either) => unrightOr$1(throws, await either);
/**
 * Tries to unwrap the left value into a promised left value. Throws error if value is right.
 * @throws Error
 *
 * @returns Promise<L>
 */
const unwrapLeft = async (either) => unleftOr$1(throws, await either);
/**
 * Unwraps a the right value into an optional value ignoring lefts by returning `none`
 *
 * @returns Promise<O.IOption<R>>
 */
const unright = async (either) => unright$1(await either);
/**
 * Unwraps a the left value into an optional value ignoring rights by returning `none`
 *
 * @returns Promise<O.IOption<L>>
 */
const unleft = async (either) => unleft$1(await either);
/**
 * Tries to unwrap the right value or uses the default value or lazy function
 * to produce the correct result(or throw error).
 *
 * @returns Promise<R>
 */
const unrightOr = async (or, either) => unrightOr$1(or, await either);
/**
 * Tries to unwrap the left value or uses the default value or lazy function
 * to produce the correct result.
 *
 * @returns Promise<L>
 */
const unleftOr = async (or, either) => unleftOr$1(or, await either);
/**
 * Maps the right value if present with the mapping function.
 *
 * @returns IAEither<L, B>
 */
const map = async (f, either$1) => either(right(f(unwrap$1(await either$1))));
/**
 * Chains eithers where it returns out a Left if one of the composed functions returns left
 * or the Right value if all succeedes.
 *
 * @returns IAEither<L, B>
 */
const bind = async (f, either$1) => {
    try {
        return either(right((await f(unwrap$1(await either$1)))));
    }
    catch (error) {
        return either(left(error));
    }
};
/**
 * Bind methods to a AEither object for utility and "syntactic" sugar over async eithers..
 *
 * @param _either AEither<L, R>
 * @returns IAEither<L, R>
 */
const aeither = (_either) => ({
    unwrap: async () => unwrap(_either),
    unwrapLeft: async () => unwrapLeft(_either),
    unright: async () => unright(_either),
    unleft: async () => unleft(_either),
    unrightOr: async (or) => unrightOr(or, _either),
    unleftOr: async (or) => unleftOr(or, _either),
    map: (f) => aeither(map(f, _either)),
    bind: (f) => aeither(bind(f, _either)),
    asEither: async () => either(await _either),
    isRight: async () => (await _either).isRight(),
    isLeft: async () => (await _either).isLeft(),
    then(onResolve, onReject) {
        _either.then(value => {
            if (isRight(value)) {
                onResolve?.(value.right);
            }
            else {
                onReject?.(value.left);
            }
        });
        return this;
    },
    catch(onReject) {
        _either.then(value => {
            if (isLeft(value)) {
                onReject?.(value.left);
            }
        });
        return this;
    },
    finally(onFinally) {
        onFinally?.();
        return this;
    },
    [Symbol.toStringTag]: `IAEither<L, R>`,
});

export { aeither, bind, from, map, unleft, unleftOr, unright, unrightOr, unwrap, unwrapLeft };
//# sourceMappingURL=index.esm.js.map

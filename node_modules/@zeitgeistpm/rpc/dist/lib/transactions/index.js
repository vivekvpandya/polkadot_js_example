'use strict';

var Te = require('@zeitgeistpm/utility/dist/taskeither');
var index = require('../keyring/index.js');
var types = require('./types.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var Te__namespace = /*#__PURE__*/_interopNamespaceDefault(Te);

const signAndSend = Te__namespace.from(async ({ api, tx, signer, hooks }) => {
    return new Promise(async (resolve, reject) => {
        let unsub;
        const callback = async (result) => {
            if (result.status.isRetracted) {
                // TODO: find out if finalized callback will still be called. or if seperate error handling is needed.
                // https://substrate.stackexchange.com/questions/5961/does-callback-get-called-when-extrinsic-is-in-block-finalized-when-the-transacti
                hooks?.retracted?.();
            }
            if (result.dispatchError) {
                if (result.dispatchError.isModule) {
                    reject(api.registry.findMetaError(result.dispatchError.asModule));
                }
                else {
                    reject(new types.UnknownDispatchError(result.dispatchError.toString()));
                }
                unsub();
            }
            if (result.internalError) {
                reject(result.internalError);
                unsub();
            }
            if (result.status.isInBlock) {
                hooks?.inBlock?.(result);
            }
            if (result.status.isFinalized) {
                resolve(result);
            }
        };
        try {
            unsub = index.isExtSigner(signer)
                ? await tx.signAndSend(signer.address, { signer: signer.signer }, callback)
                : await tx.signAndSend(signer, callback);
        }
        catch (error) {
            reject(error);
        }
    });
});

exports.signAndSend = signAndSend;
//# sourceMappingURL=index.js.map
